#!/usr/bin/perl -w

# $Id: gpt-wizard,v 1.88 2002-10-17 01:09:41-07 kst Exp $
# $Source: /home/kst/CVS_smov/tools/gpt-wizard/gpt-wizard,v $

#
# TO DO:
#
#     Start services other than GRIS (make it configurable).
#
#     May need to update lines in inetd.conf or files in xinetd.d
#     for services other than gsigatekeeper and gsiftp.
#
#     Automatically set up to report to one or more GIIS servers.
#     Configure this.
#
#     Be smarter about tarballs.  Handle .tar, .tar.gz, .tgz,
#     .tar.bz2.  Auto-detect what tar can handle (check output
#     of "tar --help") and fall back to gzip/bzip2 and pipes.
#     (Particularly useful for non-Linux systems.)
#
#     Smarter handling of flavors for source installations,
#     particularly for vendorcc; see build-gt2.
#
#     Detect 64-bit machines other than ia64.
#     If it's configurable, configure it.
#
#     Avoid interactive gpt-postinstall by patching scripts to
#     turn off interaction.  See fix-grid-security-config for
#     an example.
#

use strict;

use File::Basename ();
use Getopt::Long ();
use POSIX ();

sub Strip_Revision_String($);
sub Get_Config($);
sub Get_System_Information();
sub Download_Files(@);
sub Substitute($);
sub Elapsed_Time_Image($);
sub Time_Image($);
sub Make_Temp_File($);
sub Get_Result($$);
sub Execute(@);
sub Check_Services();
sub Die_Handler($);
sub Timestamp_Of($);
sub Backup($);
sub Test_File_Creation();
sub Inet_Config_Text($$);
sub Image($);
sub Debug(@);
sub Usage(@);

#
# Make warnings fatal.
#
$SIG{__WARN__} = sub { die @_ };

$| = 1;

my $Prog_Name         = File::Basename::basename $0;
my $Revision          = Strip_Revision_String '$Revision: 1.88 $';
my $Help              = undef;
my $Validate_Only     = undef;
my $Debugging         = undef;
my $Cleanup           = 1;
my $Postinstall       = 1;
my $Startup           = 1;
my $GPT_Verbose       = undef;
my $GPT_Log           = undef;
my $GPT_Install_Only  = undef;
my $GPT_Ignore_Errors = undef;
my @Opts = ( 'help!'              => \$Help,
             'validate-only'      => \$Validate_Only,
             'debugging!'         => \$Debugging,
             'cleanup!'           => \$Cleanup,
             'postinstall!'       => \$Postinstall,
             'startup!'           => \$Startup,
             'gpt-verbose!'       => \$GPT_Verbose,
             'gpt-log!'           => \$GPT_Log,
             'gpt-install-only!'  => \$GPT_Install_Only,
             'gpt-ignore-errors!' => \$GPT_Ignore_Errors );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $Help;

die "-gpt-log option is disabled\n" if $GPT_Log;

if ($GPT_Log and $Cleanup) {
    print "-gpt-log implies -nocleanup, setting option\n";
    $Cleanup = undef;
}

if ($Startup and not $Postinstall) {
    Usage "Option conflict: \"-startup\" and \"-nopostinstall\"\n",
          "    (Can't do startup without doing gpt-postinstall)\n";
}

$SIG{__DIE__} = \&Die_Handler;

my $temp_file_serial_number = 0;
my @manual_steps = ();

Usage if scalar @ARGV != 1;
my $Config_File = $ARGV[0];
my %Config = Get_Config $ARGV[0];

my %Sys = Get_System_Information;

exit 0 if $Validate_Only;

if ($Sys{LC_OSNAME} eq 'linux') {
    # ok
}
elsif ($Sys{LC_OSNAME} eq 'sunos' or
       $Sys{LC_OSNAME} eq 'aix') {
    if ($Startup) {
        die "Must use \"-nostartup\" on $Sys{OSNAME} (for now)\n";
    }
}
else {
    die "Unsupported OS \"$Sys{OSNAME}\"\n";
}

Check_Services;

my @As_Root      =  qw(-time=5 -verbose -check);
my @As_Installer = (qw(-time=5 -verbose -check),
                    "-user=$Config{INSTALLER_USER}.$Config{INSTALLER_GROUP}");
my @As_Installer_GPT = @As_Installer;
if ($GPT_Ignore_Errors) {
    @As_Installer_GPT = grep { $_ ne '-check' } @As_Installer;
}

my $CLK_TCK;
eval { $CLK_TCK = &POSIX::CLK_TCK };
if ($@) {
    $CLK_TCK = 100;
    # warn ">>> CLK_TCK not available, assuming 100\n";
}

if ($< != 0) {
    die ">>> $Prog_Name must be run as root\n";
}

########################################################################
# Create a temporary working directory and set some variables.
########################################################################

print Time_Image time, "\n";
print "$Prog_Name revision $Revision processing $Config_File";
if (defined $Config{CONFIG_FILE_REVISION}) {
    print " $Config{CONFIG_FILE_REVISION}\n";
}
else {
    print ", no CONFIG_FILE_REVISION specified\n";
}

my @installer_pw = getpwnam $Config{INSTALLER_USER};
die ">>> No user $Config{INSTALLER_USER}\n" unless $#installer_pw >= 2;
my @installer_gr = getgrnam $Config{INSTALLER_GROUP};
die ">>> No group $Config{INSTALLER_GROUP}\n" unless $#installer_gr >= 2;
my $installer_uid = $installer_pw[2];
my $installer_gid = $installer_gr[2];
die ">>> installer_uid = $installer_uid\n" unless $installer_uid > 0;
# die ">>> installer_gid = $installer_gid\n" unless $installer_gid > 0;

$ENV{PATH} = $Config{PATH};
umask oct $Config{UMASK} or die "umask $Config{UMASK}: $!\n";

my $working_dir = "$Config{TEMP_DIR}/install-nmi-" . time . "-$$";
print "% mkdir $working_dir\n";
mkdir $working_dir, 0700 or die "$working_dir: $!\n";
chown $installer_uid, $installer_gid, $working_dir
    or die "$working_dir: $!\n";
print "% cd $working_dir\n";
chdir $working_dir or die "$working_dir: $!\n";

########################################################################
# Download any files specified by ftp:// or http:// URLs
# For security reasons, certificates and keys may not be downloaded.
########################################################################
my @file_refs = ();

foreach my $var (qw(GPT_TARBALL GRID_MAPFILE CA_CERT_TARBALL)) {
    push @file_refs, \$Config{$var} if defined $Config{$var};
}

for (my $i = 0; $i <= $#{$Config{BUNDLE}}; $i ++) {
    push @file_refs, \$Config{BUNDLE}->[$i];
}

Download_Files @file_refs;

########################################################################
# Install GPT
########################################################################

########################################
# Unpack the source tarball.  See what the tar command created.
# If there's exactly one new thing in the current directory, assume it's
# the extracted source directory.
########################################

opendir DIR, '.' or die ".: $!\n";
my @files_before = readdir DIR;
closedir DIR;
my %already_existed = map { $_ => 1 } @files_before;

Execute @As_Installer, 'tar', 'zxf', $Config{GPT_TARBALL};

opendir DIR, '.' or die ".: $!\n";
my @files_after = readdir DIR;
closedir DIR;

my @new_files = ();
foreach my $file (@files_after) {
    push @new_files, $file if not $already_existed{$file};
}

if (scalar @new_files == 0) {
    die "Can't determine GPT source directory, tar didn't create anything\n";
}
elsif (scalar @new_files == 1) {
    my $src_dir = $new_files[0];
    print "% cd $working_dir/$src_dir\n";
    chdir "$working_dir/$src_dir" or die "$working_dir/$src_dir: $!\n";
}
else {
    die "Can't determine GPT source directory, tar created (@new_files)\n";
}

########################################
# Create the $GPT_LOCATION directory if it doesn't already exist.
# (If it exists it must be empty; this is handled in Check_Config_Vars.)
########################################

$ENV{GPT_LOCATION} = $Config{GPT_LOCATION};
if (not -d $Config{GPT_LOCATION}) {
    print "% mkdir $Config{GPT_LOCATION}\n";
    mkdir $Config{GPT_LOCATION}, 0777 or die "$Config{GPT_LOCATION}: $!\n";
    chown $installer_uid, $installer_gid, $Config{GPT_LOCATION}
        or die "$Config{GPT_LOCATION}: $!\n";
}

########################################
# Run build-gpt to install GPT
########################################
Execute @As_Installer, './build_gpt';

print "% cd $working_dir\n";
chdir $working_dir or die "$working_dir: $!\n";

########################################
# <http://www.nsf-middleware.org/documentation/GPT/index.htm>
# says to delete these two files.  They seem to be installed
# if you use the RPM, but not if you use the source tarball.
# So in reality, these files probably won't exist in the first place;
# ignore any errors from unlink().
########################################
unlink '/etc/profile.d/gpt.sh',
       '/etc/profile.d/gpt.csh';

########################################################################
# Confirm GPT installation
########################################################################
#
# In older GPT releases, the gpt-build and gpt-install commands
# are called globus-build and globus-install.
#
my $gpt_install_command = undef;
my $gpt_build_command   = undef;
my $sbin_dir = "$Config{GPT_LOCATION}/sbin";
my $using_old_gpt;

if (-x "$sbin_dir/gpt-install" and -x "$sbin_dir/gpt-build") {
    $gpt_install_command = "$sbin_dir/gpt-install";
    $gpt_build_command   = "$sbin_dir/gpt-build";
    $using_old_gpt = 0;
}
elsif (-x "$sbin_dir/globus-install" and -x "$sbin_dir/globus-build") {
    $gpt_install_command = "$sbin_dir/globus-install";
    $gpt_build_command   = "$sbin_dir/globus-build";
    $using_old_gpt = 1;
}
else {
    die "Can't find install and build commands in $sbin_dir\n";
}

#
# Verify GPT installation.
# For recent releases of GPT, verify that "gpt-install -version" succeeds.
# In older releases, globus-install doesn't support the "-version"
# option; we've already checked that the command exists.
#
if (not $using_old_gpt) {
    Execute @As_Installer, $gpt_install_command, '-version';
}

########################################################################
# Install bundles (presumably Globus et al)
########################################################################

########################################
# Create the $GLOBUS_LOCATION directory if it doesn't already exist.
# (If it exists it must be an empty directory; this is handled in
# Check_Config_Vars.)
########################################
$ENV{GLOBUS_LOCATION} = $Config{GLOBUS_LOCATION};
if ($Config{GLOBUS_LOCATION} ne $Config{GPT_LOCATION}) {
    if (not -d $Config{GLOBUS_LOCATION}) {
        print "% mkdir $Config{GLOBUS_LOCATION}\n";
        mkdir $Config{GLOBUS_LOCATION}, 0777
            or die "$Config{GLOBUS_LOCATION}: $!\n";
        chown $installer_uid, $installer_gid, $Config{GLOBUS_LOCATION}
            or die "$Config{GLOBUS_LOCATION}: $!\n";
    }
}

########################################
# Run gpt-install or gpt-build to install the bundles.
########################################
my $Installing_kx509 = 0;

foreach my $bundle ( @{$Config{BUNDLE}} ) {
    my $bundle_name = File::Basename::basename $bundle;

    #
    # If we're installing kx509, we'll need to supply more
    # input to gpt-postinstall.  Ick.
    #
    if ($bundle_name =~ /^kx509/ or $bundle_name =~ /^nmi/) {
        $Installing_kx509 = 1;
    }

    #
    # If the file name contains the string "src", assume it's a source
    # bundle; "src" must be preceded and followed by either an underscore
    # or a word boundary.
    #
    # If this assumption breaks, consider specifying source vs. binary
    # in the config file (or detecting it?).
    #
    if ($bundle_name =~ /(\b|_)src(\b|_)/) {
        #
        # Using gpt-build to build and install a source bundle.
        #
        my @options = ();
        if ($GPT_Verbose) {
            push @options, '-verbose';
        }
        if ($GPT_Log) {
            my $logfile = File::Basename::basename $bundle . ".log";
            push @options, "-log=$logfile";
        }
        if ($GPT_Install_Only) {
            push @options, '-install-only';
        }

        my @flavors = ();
        if ($bundle_name =~ /^globus/) {
            if ($bundle_name =~ /^globus_(data|resource).*-server/) {
                push @options, '-static=1';
            }
            if ($bundle_name =~ /^globus_information/) {
                push @flavors, "$Config{CC}$Sys{BITS}dbgpthr";
            }
            else {
                push @flavors, "$Config{CC}$Sys{BITS}dbg";
            }
            $flavors[$#flavors] .= 'mpi' if $Config{USE_MPI};
        }
        else {
            push @options, '-std-flavors';
        }
        Execute @As_Installer_GPT,
                $gpt_build_command, @options, $bundle, @flavors;
    }
    else {
        #
        # Using gpt-install to install a binary bundle.
        #
        my @options = ();
        if ($GPT_Verbose and not $using_old_gpt) {
            push @options, '-verbose';
        }
        #
        # $GPT_Log and $GPT_Install_Only are inapplicable for gpt-install.
        #
        Execute @As_Installer_GPT,
                $gpt_install_command, @options, $bundle;
    }
}

########################################
# If GLOBUS_VAR_DIRECTORY is defined in the config file, make
# $GLOBUS_LOCATION/var a symlink to it (after copying it if it exists,
# or creating it if it doesn't).
# (The $GLOBUS_LOCATION/var directory must be on a local filesystem,
# so root can write to logs.)
########################################
if (defined $Config{GLOBUS_VAR_DIRECTORY}) {
    if (-d "$ENV{GLOBUS_LOCATION}/var") {
        Execute @As_Root, 'cp', '-pr', "$ENV{GLOBUS_LOCATION}/var",
                                       $Config{GLOBUS_VAR_DIRECTORY};
        Execute @As_Root, 'rm', '-rf', "$ENV{GLOBUS_LOCATION}/var";
    }
    else {
        print "% mkdir $Config{GLOBUS_VAR_DIRECTORY}\n";
        mkdir $Config{GLOBUS_VAR_DIRECTORY}, 0700
            or die "$Config{GLOBUS_VAR_DIRECTORY}: $!\n";
        chown $installer_uid, $installer_gid, $Config{GLOBUS_VAR_DIRECTORY}
            or die "$Config{GLOBUS_VAR_DIRECTORY}: $!\n";
    }
    symlink $Config{GLOBUS_VAR_DIRECTORY}, "$ENV{GLOBUS_LOCATION}/var"
        or die "$ENV{GLOBUS_LOCATION}/var: $!\n";
}


########################################################################
# Post-installation
########################################################################

########################################
# Run gpt-postinstall.
# Annoyingly, it waits for user input; what input is required depends
# on what was installed.
# Make an educated guess about what input is needed, and force-feed it
# to keep it happy.
# <RANT> BUILD SCRIPTS SHOULD NOT WAIT FOR USER INPUT! </RANT>
########################################
if ($Postinstall) {
    my $input_string = "";
    $input_string .= "0\n0\nn\n" if $Installing_kx509;
    $input_string .= "\n"; # Globus

    Execute @As_Installer, "-input=$input_string",
            "$Config{GPT_LOCATION}/sbin/gpt-postinstall";
}
else {
    push @manual_steps,
         "Run $Config{GPT_LOCATION}/sbin/gpt-postinstall\n";
}

####################################
# The LDAP certificate and key need to be in $GLOBUS_LOCATION/etc,
# not in /etc/grid-security.  I'm not sure why.
####################################
if (defined $Config{LDAP_CERT}) {
    Backup "$Config{GLOBUS_LOCATION}/etc/server.cert";
    Execute @As_Installer,
            'cp', $Config{LDAP_CERT},
                  "$Config{GLOBUS_LOCATION}/etc/server.cert";
    chmod 0444, "$Config{GLOBUS_LOCATION}/etc/server.cert";
}
else {
    push @manual_steps,
         "Create \$GLOBUS_LOCATION/etc/server.cert, " .
         "mode 444, owned by $Config{INSTALLER_USER}\n";
}

if (defined $Config{LDAP_KEY}) {
    Backup "$Config{GLOBUS_LOCATION}/etc/server.key";
    Execute @As_Installer,
            'cp', $Config{LDAP_KEY},
                  "$Config{GLOBUS_LOCATION}/etc/server.key";
    chmod 0400, "$Config{GLOBUS_LOCATION}/etc/server.key";
}
else {
    push @manual_steps,
         "Create \$GLOBUS_LOCATION/etc/server.key, " .
         "mode 444, owned by $Config{INSTALLER_USER}\n";
}

########################################
# Configure batch jobmanager
########################################

if (defined $Config{BATCH_SYSTEM}) {
    Execute @As_Installer,
        "$Config{GLOBUS_LOCATION}/setup/globus/setup-globus-gram-job-manager",
        "-type=$Config{BATCH_SYSTEM}";
    my $libexec = "$Config{GLOBUS_LOCATION}/libexec";
    push @manual_steps,
         "Fix $Config{GLOBUS_LOCATION}/libexec/" .
         "globus-script-$Config{BATCH_SYSTEM}-* if necessary\n";
}

########################################
# Run setup-gsi to create /etc/grid-security
# (but we're going to replace its contents in a moment).
########################################
if ($Startup) {
    Execute @As_Root, "-input=y\nq\n",
            "$Config{GLOBUS_LOCATION}/setup/globus/setup-gsi";
}
else {
    push @manual_steps,
         "As root, run $Config{GLOBUS_LOCATION}/setup/globus/setup-gsi\n";
}

########################################
# Now copy files to /etc/grid-security.
########################################
if ($Startup) {
    if (defined $Config{GRID_MAPFILE}) {
        Backup '/etc/grid-security/grid-mapfile';
        Execute @As_Root,
                'cp', $Config{GRID_MAPFILE}, '/etc/grid-security/grid-mapfile';
        chmod 0444, '/etc/grid-security/grid-mapfile';
    }
    else {
        push @manual_steps,
             "Create /etc/grid-security/grid-mapfile, " .
             "mode 444, owned by root\n";
    }

    if (defined $Config{HOST_CERT}) {
        Backup '/etc/grid-security/hostcert.pem';
        Execute @As_Root,
                'cp', $Config{HOST_CERT}, '/etc/grid-security/hostcert.pem';
        chmod 0444, '/etc/grid-security/hostcert.pem';
    }
    else {
        push @manual_steps,
             "Create /etc/grid-security/hostcert.pem, " .
             "mode 444, owned by root\n";
    }

    if (defined $Config{HOST_KEY}) {
        Backup '/etc/grid-security/hostkey.pem';
        Execute @As_Root,
                'cp', $Config{HOST_KEY}, '/etc/grid-security/hostkey.pem';
        chmod 0400, '/etc/grid-security/hostkey.pem';
    }
    else {
        push @manual_steps,
             "Create /etc/grid-security/hostkey.pem, " .
             "mode 400, owned by root\n";
    }
}
else {
    push @manual_steps,
         "Set up /etc/grid-security directory.\n" .
         "Create /etc/grid-security/grid-mapfile, mode 444, owned by root\n" .
         "Create /etc/grid-security/hostcert.pem, mode 444, owned by root\n" .
         "Create /etc/grid-security/hostkey.pem,  mode 400, owned by root\n";
}

if ($Startup and defined $Config{CA_CERT_TARBALL}) {
    my $ca_cert_dir = '/etc/grid-security/certificates';
    Backup $ca_cert_dir;
    print "% mkdir $ca_cert_dir\n";
    mkdir $ca_cert_dir, 0777 or die "$ca_cert_dir: $!\n";
    print "% cd $ca_cert_dir\n";
    chdir $ca_cert_dir or die "$ca_cert_dir: $!\n";
    Execute @As_Root, 'tar', 'zxf', $Config{CA_CERT_TARBALL};
}
else {
    push @manual_steps,
         "Copy CA certificates and signing-policy files to\n" .
         "/etc/grid-security/certificates\n";
}

if ($Sys{NET_DAEMON} eq 'xinetd') {
    my $xinetd_dir = '/etc/xinetd.d';
    if (not -d $xinetd_dir) {
        push @manual_steps,
             "You seem to be running xinetd, but there is " .
             "no $xinetd_dir directory.\n" .
             "Your humble installation script is confused.\n" .
             "You're on your own.\n";
    }
    else {
        if ($Startup) {
            my $file1 = "$xinetd_dir/gsigatekeeper";
            Backup $file1;
            open FILE, "> $file1" or die "${file1}: $!\n";
            print FILE Inet_Config_Text 'xinetd', 'gsigatekeeper';

            my $file2 = "$xinetd_dir/gsiftp";
            Backup $file2;
            open FILE, "> $file2" or die "${file2}: $!\n";
            print FILE Inet_Config_Text 'xinetd', 'gsiftp';
            Execute @As_Root, qw(/etc/init.d/xinetd reload);
        }
        else {
            push @manual_steps,
                 "Set up xinetd scripts for gsigatekeeper and gsiftp\n";
        }
    }
}
else {
    #
    # For inetd, we need to update /etc/inetd.conf.
    # Since this involves editing an existing file (which requires
    # some care about its previous contents), and some sites might
    # want to use things like tcpd, we'll let the user do this manually.
    #
    my $update = "Update /etc/inetd.conf:\n";

    $update .= "gsigatekeeper:\n";
    $update .= "gsigatekeeper   stream tcp nowait root " .
               "$Config{GLOBUS_LOCATION}/sbin/globus-gatekeeper " .
               "globus-gatekeeper " .
               "-conf $Config{GLOBUS_LOCATION}/etc/globus-gatekeeper.conf\n";

    $update .= "gsiftp:\n";
    $update .= "gsiftp  stream  tcp     nowait  root    " .
               "$Config{GLOBUS_LOCATION}/sbin/in.ftpd in.ftpd -l -a";

    $update .= "Allow for any site-specific conventions for /etc/inetd.conf\n";

    $update .= "Execute as root \"$Sys{NET_DAEMON_RELOAD}\"\n";
    push @manual_steps, $update;
}

if ($Startup) {
    Execute @As_Installer,
            "$Config{GLOBUS_LOCATION}/sbin/SXXgris", 'start';
}
else {
    push @manual_steps,
         "As $Config{INSTALLER_USER} run " .
         "$Config{GLOBUS_LOCATION}/sbin/SXXgris start\n";
}

push @manual_steps,
     "Arrange for \"$Config{GLOBUS_LOCATION}/sbin/SXXgris start\"\n" .
     "to be executed by user \"$Config{INSTALLER_USER}\" on system boot\n";

push @manual_steps,
     "Start any other desired services\n";

push @manual_steps,
     "Configure to report to a GIIS server if desired\n";

chdir '/tmp';
if ($Cleanup) {
    Execute @As_Root, 'rm', '-rf', $working_dir;
}

########################################################################
# Some things can't be easily automated, some things shouldn't be
# automated, and some things I just haven't gotten around to automating
# yet.  Tell the user what still needs to be done manally.  All these
# things are collected and printed in one well-marked block at the end
# of the log.
########################################################################
my $text = ">>> To be done manually:\n" .
           join "\n", @manual_steps;
$text =~ s/^/* /gm;
print '*' x 72, "\n";
print $text;
print '*' x 72, "\n";

print Time_Image time, "\n";

########################################################################
# Subroutines
########################################################################

#
# Extract the actual revision number from an RCS revision string.
# The code is a little convoluted to prevent RCS from stepping on
# the search pattern.
#
sub Strip_Revision_String($) {
    my($revision) = @_;
    my $rev_tag = '\$' . 'Revision:';
    if ($revision =~ /^$rev_tag ([\d.]+) \$$/) {
        return $1;
    }
    else {
        return $revision;
    }
} # Strip_Revision_String

# ----------------------------------------------------------------------

#
# Called by Get_Config.
# Return an error message for a given filename or URL.
# Return undef if there's no problem.
#
sub File_Or_URL_Error($$$) {
    my ($varname, $value, $url_ok) = @_;

    if ($value =~ m<^(\w+)://>) {
        if ($url_ok) {
            if ($1 eq 'http' or $1 eq 'ftp') {
                return undef;
            }
            else {
                return "$varname URL \"$value\", unsupported protocol\n";
            }
        }
        else {
            return "$varname file \"$value\", URL not allowed\n";
        }
    }
    else {
        if ($value !~ /^\//) {
            return "$varname file \"$value\", relative path not allowed\n";
        }
        elsif (not -e $value) {
            return "$varname file \"$value\" does not exist\n";
        }
        elsif (not -f _) {
            return "$varname file \"$value\" is not an ordinary file\n";
        }
        elsif (not -r _) {
            return "Can't read $varname file \"$value\"\n";
        }
        elsif (-z _) {
            return "$varname file \"$value\" is empty\n";
        }
        else {
            return undef;
        }
    }
} # File_Or_URL_Error

# ----------------------------------------------------------------------

#
# Read and parse the config file (name given on the command line) and
# return the results as a hash (to be assigned to the global %Config).
#
sub Get_Config($) {
    my %Result = ();
    my($config_file) = @_;
    my @errors = ();

    #
    # %Var_Info is a hash of hash references.
    # Each element is basically a declaration for a configuration variable.
    # This information is used for validity checking, and is local
    # to Get_Config.
    #
    my %Var_Info = (
        CONFIG_FILE_REVISION =>
            { type => 'string', required => 0 },
        TEMP_DIR =>
            { type => 'existing_directory', required => 0, default => '/tmp' },
        PATH =>
            { type => 'path', required => 1 },
        INSTALLER_USER =>
            { type => 'user_name', required => 0, default => 'globus' },
        INSTALLER_GROUP =>
            { type => 'group_name', required => 0, default => 'globus' },
        UMASK =>
            { type => 'umask', required => 0, default => '022' },
        CC =>
            { type => 'cc', required => 1 },
        USE_MPI =>
            { type => 'boolean', required => 0, default => 0 },
        GPT_TARBALL =>
            { type => 'file_or_url', required => 1 },
        BUNDLE =>
            { type => 'array_of_file_or_url', required => 1 },
        GPT_LOCATION =>,
            { type => 'new_directory', required => 1 },
        GLOBUS_LOCATION =>
            { type => 'new_directory', required => 1 },
        GLOBUS_VAR_DIRECTORY =>
            { type => 'new_directory', required => 0 },
        GRID_MAPFILE =>
            { type => 'file_or_url', required => 0 },
        HOST_CERT =>
            { type => 'file', required => 0 },
        HOST_KEY =>
            { type => 'file', required => 0 },
        LDAP_CERT =>
            { type => 'file', required => 0 },
        LDAP_KEY =>
            { type => 'file', required => 0 },
        BATCH_SYSTEM =>
            { type => 'batch_system', required => 0 },
        CA_CERT_TARBALL =>
            { type => 'file_or_url', required => 0 }
    );

    print "Getting configuration from $config_file\n";

    #
    # Read config variables from config file.
    # Check for duplicate entries, unrecognized names, and syntax errors.
    #
    open CONFIG, $config_file or die "$config_file: $!\n";
    while (<CONFIG>) {
        #
        # Strip comments (note that '#' introduces a comment, even in
        # a string literal).
        # Strip leading and trailing whitespace.
        # Skip empty lines.
        #
        s/#.*$//;
        s/^\s+//;
        s/\s+$//;
        next if /^$/;
        if (/^(\w+)\s+(.*)$/) {
            my ($name, $value) = ($1, $2);
            if (defined $Var_Info{$name}) {
                my $Var = $Var_Info{$name};

                if ($Var->{type} =~ /^array_of/) {
                    push @{$Var->{value}}, $value;
                }
                else {
                    if (defined $Var->{value}) {
                        push @errors,
                             "Duplicate entry for \"$name\" at line $.\n";
                    }
                    else {
                        $Var->{value} = $value;
                    }
                }
            }
            else {
                push @errors, "Unrecognized option \"$name\" at line $.\n"
            }
        }
        else {
            push @errors, "Syntax error at line $.\n";
        }
    }
    close CONFIG;

    #
    # Validate each variable, depending on its type.
    #
    VAR:
    foreach my $varname (sort keys %Var_Info) {
        my $var = $Var_Info{$varname};
        if (not defined $var->{value}) {
            if ($var->{required}) {
                push @errors, "Missing option $varname\n";
            }
            elsif (defined $var->{default}) {
                $var->{value} = $var->{default};
            }
            else {
                $var->{value} = undef;
                next VAR;
            }
        }

        #
        # An arbitrary string.
        #
        if ($var->{type} eq 'string') {
            #
            # Nothing to validate
            #
        }

        #
        # An existing directory.
        # It must be readable, writable, and searchable.
        #
        elsif ($var->{type} eq 'existing_directory') {
            if (not (-d $var->{value} and -r _ and -w _ and -x _)) {
                push @errors, "Bad $varname directory \"$var->{value}\"\n";
            }
        }

        #
        # A directory to be created.
        # It must not exist.
        #
        elsif ($var->{type} eq 'new_directory') {
            my $dir = $var->{value};
            if (-e $dir) {
                push @errors, "$varname \"$dir\" already exists\n";
            }
        }

        #
        # A path, consisting of a colon-delimited list of directories.
        # Each directory must exist, and must be readable and searchable.
        #
        elsif ($var->{type} eq 'path') {
            foreach my $dir (split /:/, $var->{value}) {
                if ($dir !~ /^\//) {
                    push @errors,
                         "Bad directory in ${varname}: \"$dir\"\n";
                }
                elsif (not -d $dir) {
                    push @errors,
                         "Nonexistent directory in ${varname}: \"$dir\"\n";
                }
                elsif (not -r $dir or not -x $dir) {
                    push @errors,
                         "Bad permissions on directory in " .
                         "${varname}: \"$dir\"\n";
                }
            }
        }

        #
        # A non-root Unix user name.
        #
        elsif ($var->{type} eq 'user_name') {
            my @pw = getpwnam $var->{value};
            if (not defined $pw[2]) {
                push @errors, "Bad $varname \"$var->{value}\", no such user\n";
            }
            elsif ($pw[2] <= 0) {
                push @errors, "Bad $varname \"$var->{value}\", uid = $pw[2]\n";
            }
        }

        #
        # A non-root Unix group name.
        #
        elsif ($var->{type} eq 'group_name') {
            my @gr = getgrnam $var->{value};
            if (not defined $gr[2]) {
                push @errors, "Bad $varname \"$var->{value}\", no such group\n";
            }
            elsif ($gr[2] <= 0) {
                push @errors, "Bad $varname \"$var->{value}\", gid = $gr[2]\n";
            }
        }

        #
        # A umask, a sequence of one or more octal digits.
        #
        elsif ($var->{type} eq 'umask') {
            if ($var->{value} !~ /^[0-7]+$/) {
                push @errors, "Bad $varname \"$var->{value}\"\n";
            }
        }

        #
        # A C compiler, to be used in a GPT flavor string.
        # Either 'gcc' or 'vendorcc'.
        #
        elsif ($var->{type} eq 'cc') {
            if ($var->{value} ne 'gcc' and $var->{value} ne 'vendorcc') {
                push @errors, "$varname must be \"gcc\" or \"vendorcc\"\n";
            }
        }

        #
        # A Boolean value.
        # False may be represented as '0', 'no', or 'false'.
        # True may be represented as '1', 'yes', or 'true'.
        # Value is case-insensitive.
        #
        elsif ($var->{type} eq 'boolean') {
            if ($var->{value} eq '0' or
                lc $var->{value} eq 'no' or
                lc $var->{value} eq 'false')
            {
                $var->{value} = 0;
            }
            elsif ($var->{value} eq '1' or
                lc $var->{value} eq 'yes' or
                lc $var->{value} eq 'true')
            {
                $var->{value} = 1;
            }
            else {
                push @errors, "$varname must be one of the following:\n" .
                              "    0, no, false, 1, yes, true\n";
            }
        }

        #
        # A filename or a URL.
        # See File_Or_URL_Error().
        # 
        elsif ($var->{type} eq 'file_or_url') {
            my $error = File_Or_URL_Error $varname, $var->{value}, 1;
            push @errors, $error if defined $error;
        }

        elsif ($var->{type} eq 'array_of_file_or_url') {
            foreach my $item (@{$var->{value}}) {
                my $error = File_Or_URL_Error $varname, $item, 1;
                push @errors, $error if defined $error;
            }
        }

        elsif ($var->{type} eq 'file') {
            my $error = File_Or_URL_Error $varname, $var->{value}, 0;
            push @errors, $error if defined $error;
        }

        elsif ($var->{type} eq 'batch_system') {
            $var->{value} = lc $var->{value};

            my @batch_systems = qw( condor easymcs fork glunix grd
                                    loadleveler lsf nqe nswc pbs pexec
                                    prun );
            my %is_batch_system = map { ( $_ => 1 ) } @batch_systems;
            if (not $is_batch_system{$var->{value}}) {
                push @errors, "$varname must be one of:\n" .
                              "    @batch_systems\n";
            }

        }

        else {
            #
            # The missing "\n" in the error message is deliberate.
            # It causes Perl to print more information about the location
            # of the error.
            #
            die "Internal error, bad variable type \"$var->{type}\"";
        }

    }

    if (defined $Var_Info{CONFIG_FILE_REVISION}->{value}) {
        $Var_Info{CONFIG_FILE_REVISION}->{value} =
            Strip_Revision_String $Var_Info{CONFIG_FILE_REVISION}->{value};
    }

    #
    # Special check: GLOBUS_VAR_DIRECTORY may not be a subdirectory
    # of GLOBUS_LOCATION.
    #
    if (defined $Var_Info{GLOBUS_VAR_DIRECTORY}->{value}) {
        my $globus_dir = $Var_Info{GLOBUS_LOCATION}->{value};
        my $var_dir = $Var_Info{GLOBUS_VAR_DIRECTORY}->{value};
        if ($var_dir =~ /^\Q$globus_dir\E\//) {
            push @errors, "GLOBUS_VAR_DIRECTORY may not be a subdirectory of " .
                          "GLOBUS_LOCATION\n" .
                          "To use \$GLOBUS_LOCATION/var, don't specify " .
                          "GLOBUS_VAR_DIRECTORY.\n";
        }
    }

    if (@errors) {
        my $Error_s = (scalar @errors == 1 ? 'Error' : 'Errors');
        die ">>> $Error_s in config file ${config_file}:\n",
            @errors;
    }
    else {
        foreach my $varname (keys %Var_Info) {
            $Result{$varname} = $Var_Info{$varname}->{value};
        }
    }

    foreach my $key (sort keys %Result) {
        my $value = $Result{$key};
        if (ref $value eq 'ARRAY') {
            printf "    %-20s => {\n", $key;
            foreach my $elem (@$value) {
                print "        \"$elem\"\n";
            }
            print "    }\n";
        }
        else {
            printf "    %-20s => %s\n",
                   $key,
                   defined $value ? "\"$value\"" : 'undef';
        }
    }

    return %Result;
} # Get_Config

# ----------------------------------------------------------------------

#
# Collect system information and return it in a hash.
#
sub Get_System_Information() {
    my %Result = ();

    chomp($Result{OSNAME}  = `uname -s`);
    chomp($Result{MACHINE} = `uname -m`);
    $Result{LC_OSNAME}  = lc $Result{OSNAME};
    $Result{LC_MACHINE} = lc $Result{MACHINE};

    if ($Result{LC_MACHINE} eq 'ia64') {
        $Result{BITS} = 64;
    }
    else {
        $Result{BITS} = 32;
    }

    #
    # Detect whether we're running inetd or xinetd, and what its PID is.
    #
    my $ps_command;

    if ($Result{LC_OSNAME} eq 'darwin' or $Result{LC_OSNAME} =~ /bsd/) {
        $ps_command = 'ps -u -U root';
    }
    else {
        $ps_command = 'ps -f -u root';
    }

    my @inetd_processes = ();
    my @xinetd_processes = ();

    open PIPE, "$ps_command |";
    while (<PIPE>) {
        chomp;
        s/^\s*//;
        my @fields = split;
        my $pid = $fields[1];
        if (/\binetd\b/) {
            push @inetd_processes, $pid;
        }
        elsif (/\bxinetd\b/) {
            push @xinetd_processes, $pid;
        }
    }
    close PIPE;

    if (scalar @inetd_processes == 1 and scalar @xinetd_processes == 0) {
        $Result{NET_DAEMON} = 'inetd';
        $Result{NET_DAEMON_PID} = $inetd_processes[0];
        if (-x '/etc/init.d/inet') {
            $Result{NET_DAEMON_RELOAD} = '/etc/init.d/inet reload';
        }
        elsif (-x '/etc/rc.d/init.d/inet') {
            $Result{NET_DAEMON_RELOAD} = '/etc/rc.d/init.d/inet reload';
        }
        else {
            $Result{NET_DAEMON_RELOAD} = "kill -HUP $Result{NET_DAEMON_PID}";
        }
    }
    elsif (scalar @inetd_processes == 0 and scalar @xinetd_processes == 1) {
        $Result{NET_DAEMON} = 'xinetd';
        $Result{NET_DAEMON_PID} = $xinetd_processes[0];
        if (-x '/etc/init.d/xinetd') {
            $Result{NET_DAEMON_RELOAD} = '/etc/init.d/xinetd reload';
        }
        elsif (-x '/etc/rc.d/init.d/xinetd') {
            $Result{NET_DAEMON_RELOAD} = '/etc/rc.d/init.d/xinetd reload';
        }
        else {
            $Result{NET_DAEMON_RELOAD} = '';
        }
    }

    print "System Information:\n";
    foreach my $key (sort keys %Result) {
        my $value = $Result{$key};
        if (ref $value eq 'ARRAY') {
            printf "    %-20s => {\n", $key;
            foreach my $elem (@$value) {
                print "        \"$elem\"\n";
            }
            print "    }\n";
        }
        else {
            printf "    %-20s => \"%s\"\n", $key, $Result{$key};
        }
    }

    return %Result;
} # Get_System_Information

# ----------------------------------------------------------------------

#
# Download any files specified by an "http://" or "ftp://" URL.
# Update $Config entries to point to downloaded files.
#
# Arguments are references to file names.
#
sub Download_Files(@) {
    my @refs = @_;
    my $index = 0;
    my $changed_dir = 0;

    foreach my $ref (@refs) {
        if ($$ref =~ m<^(ftp|http)://>) {
            my $method = $1;
            my $target_dir  = sprintf "%s/%03d", $working_dir, $index++;
            my $target_file = "$target_dir/" .
                              File::Basename::basename $$ref;

            print "% mkdir $target_dir\n";
            mkdir $target_dir, 0777 or die "$target_dir: $!\n";
            chown $installer_uid, $installer_gid, $target_dir
                or die "$target_dir: $!\n";

            print "% cd $target_dir\n";
            chdir $target_dir or die "$target_dir: $!\n";
            $changed_dir = 1;

            if ($method eq 'ftp') {
                $changed_dir = 1;
                Execute @As_Installer, 'ncftpget', '-V', $$ref;
            }
            elsif ($method eq 'http') {
                Execute @As_Installer,
                        'wget', '-o', '/dev/null', $$ref;
            }
            if (not -e $target_file) {
                die "Download failed for $target_file (no file)\n";
            }
            elsif (-s $target_file == 0) {
                die "Download failed for $target_file (empty file)\n";
            }

            $$ref = $target_file;
        }
    }

    if ($changed_dir) {
        print "% cd $working_dir\n";
        chdir $working_dir or die "$working_dir: $!\n";
    }
} # Download_Files

# ----------------------------------------------------------------------

sub Substitute($) {
    my($key) = @_;
    if (defined $Config{$key}) {
        return $Config{$key};
    }
    else {
        die "Unrecognized substitution key: $key\n";
    }
} # Substitute

# ----------------------------------------------------------------------

#
# Given a number of seconds (possibly fractional), return a readable
# string, similar to the format used by the csh "time" builtin command.
#
sub Elapsed_Time_Image($) {
    my($seconds) = @_;

    my $h = int($seconds / 3600);
    $seconds -= 3600 * $h;      # Can't use "%"; it truncates.

    my $m = int($seconds / 60);
    $seconds -= 60 * $m;

    if ($h > 0) {
        return sprintf '%d:%02d:%05.2f', $h, $m, $seconds;
    }
    else {
        return sprintf '%d:%05.2f', $m, $seconds;
    }
} # Elapsed_Time_Image

# ----------------------------------------------------------------------

#
# Given a raw timestamp, return a human-readable string.
# Time zone is UTC, format is basically ISO-8601.
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime time;
    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
} # Time_Image

# ----------------------------------------------------------------------

#
# Create a unique temporary file and return its name.
#
sub Make_Temp_File($) {
    my($content) = @_;
    my $filename = sprintf "$working_dir/input-%03d",
                           $temp_file_serial_number ++;
    open TMP, ">$filename" or die "${filename}: $!\n";
    print TMP $content;
    close TMP;
    return $filename;
} # Make_Temp_File

# ----------------------------------------------------------------------

#
# Given a numeric value returned by system(), interpret it
# and return the result as a hash reference.
# Die if result indicates failure and second argument (check) is true.
# Print a message on failure if check is false.
#
# Note: die'ing and/or printing a message from this routine is a bit ugly,
# but it's useful in the context of this program (install-nmi).
#
sub Get_Result($$) {
    my ($status, $check) = @_;
    my $Result = {};
    my $hi_8 = ($status & 0xff00) >> 8;
    my $lo_8 =  $status & 0x00ff;

    my $WSTOPFLG = 0x007f;
    my $WCOREFLG = 0x0080;

    if ($lo_8 == $WSTOPFLG) {
        #
        # Stopped by signal
        #
        $Result->{signal} = $hi_8;
        $Result->{stopped} = 1;
        $Result->{desc} = "stopped, signal $hi_8";
        if ($check) {
            die "$Result->{desc}\n";
        }
        else {
            print "[$Result->{desc}]\n";
        }
    }
    elsif ($lo_8 == 0) {
        #
        # Normal exit() (possibly with non-zero status)
        #
        $Result->{status} = $hi_8;
        $Result->{desc} = "exit $hi_8";
        if ($Result->{status} != 0) {
            if ($check) {
                die "$Result->{desc}\n";
            }
            else {
                print "[$Result->{desc}]\n";
            }
        }
    }
    elsif ($hi_8 == 0) {
        #
        # Killed by signal
        #
        my $signal = $lo_8;
        if ($signal & $WCOREFLG) {
            $signal &= ~$WCOREFLG;
            $Result->{core} = 1;
        }
        $Result->{signal} = $signal;
        $Result->{desc} = "signal $signal";
        if ($Result->{core}) {
            $Result->{desc} .= " (core dumped)";
        }
        if ($check) {
            die "$Result->{desc}\n"
        }
        else {
            print "[$Result->{desc}]\n";
        }
    }
    return $Result;
} # Get_Result

# ----------------------------------------------------------------------

#
# Execute a command with arguments.
# The command name is preceded by zero or more options starting with '-'.
#
# -verbose      Print command to stdout before executing.
# -time         Like csh "time" command
# -time=N       Show time only if command took at least N wall seconds
# -background   Run command in background; don't wait for completion.
# -check        Die if command fails.
# -user=name    Execute as specified user (and group).
#               Name can be "user", "user.group", or "user:group".
# -stdin=file   Redirect stdin from specified file.
# -input=string Redirect stdin from temp file with specified contents.
#
# 
sub Execute(@) {
    my @args = @_;
    my $Verbose = 0;
    my $Min_Time = undef;
    my $Background = 0;
    my $Check = 0;
    my $User = undef;
    my $Group = undef;
    my $Input_String = undef;
    my $Stdin = undef;
    my $Stdin_Is_Temporary = undef;
    my @before;
    my @after;
    my $system_result;

    Debug "Execute, scalar \@args = ", scalar @args, "\n";
    my @caller = caller;
    Debug "   Called from $caller[0]::$caller[1] line $caller[2]\n";
    #
    # Process arguments
    #
    while ( scalar @args > 0 && $args[0] =~ /^-/) {
        my $arg = shift @args;
        if ($arg eq '-verbose') {
            $Verbose = 1;
        }
        elsif ($arg eq '-time') {
            $Min_Time = 0;
        }
        elsif ($arg =~ /^-time=(\d+)$/) {
            $Min_Time = $1;
        }
        elsif ($arg eq '-background') {
            $Background = 1;
        }
        elsif ($arg eq '-check') {
            $Check = 1;
        }
        elsif ($arg =~ /^-user=(.+)$/) {
            $User = $1;
            if ($User =~ /^(.*)[.:](.*)$/) {
                $User = $1;
                $Group = $2;
            }
        }
        elsif ($arg =~ /^-stdin=(.+)$/) {
            $Stdin = $1;
        }
        elsif ($arg =~ /^-input=(.+)$/s) {
            #
            # Need to use "/s" modifier so "." matches "\n"
            #
            $Input_String = $1;
            $Stdin = Make_Temp_File $Input_String;
            $Stdin_Is_Temporary = 1;
        }
        else {
            die "Execute: Unrecognized argument: $arg\n";
        }
    }

    Debug "   args = @args\n";
    if (defined $User) {
        my @pw = getpwnam $User;
        die "${User}: No such user\n" if not @pw;
        my @gr;
        if (defined $Group) {
            @gr = getgrnam $Group;
            die "${Group}: No such group\n" if not @gr;
        }
        my $uid = $pw[2];
        my $gid = defined $Group ? $gr[2] : $pw[3];
        my $pid;
        if (($pid = fork) == 0) {
            #
            # This is the child process.
            # Set the real and effective user (and group) id,
            # and continue to handle the call.
            #
            # To be honest, I don't quite understand the distinction
            # between "real" and "effective" user and group ids, so I
            # set both just to be sure.
            #
            # It may be possible to temporarily set the effective(?) user
            # and group ids, run the command, and set them back, without
            # forking a child process, but it doesn't seem to be possible
            # to do this in a portable and reliable manner.
            #
            # Set the group ids first; once we set the user ids, we're no
            # longer root and don't have permission to set the group ids.
            #
            if (defined $gid) {
                $( = $gid;
                $) = $gid;
            }
            $< = $uid;
            $> = $uid;
            Debug "Child: \$< = $< \$> = $>\n";
            delete $SIG{__DIE__};
        }
        else {
            #
            # This is the parent process.
            # Wait for the child to finish.  
            #
            Debug "Parent calling waitpid\n";
            if (waitpid $pid, 0 == -1) {
                Debug ">>> waitpid returned -1, \$? = $?, \$! = $!\n",
                      "    Ignoring error (ick)\n";
                # die "waitpid ${pid}: $! (\$? = $?)\n";
            }
            Debug "Parent after waitpid, \$? = $?\n";
            return Get_Result $?, $Check;
        }
    }

    if (defined $Min_Time) {
        print Time_Image time, "\n";
    }

    if ($Verbose) {
        Debug "Building command_string, args = @args\n";
        my $command_string = '% ';
        $command_string .= "[$User] " if defined $User;
        $command_string .= "@args";
        $command_string .= " < $Stdin" if defined $Stdin;
        $command_string .= " &" if $Background;
        print "$command_string\n";
        if (defined $Input_String) {
            print "  (input is ", Image $Input_String, ")\n";
        }
    }

    if ($Background) {
        my $pid = fork;
        if ($pid != 0) {
            #
            # I'm the parent
            #
            my $Result = {};
            $Result->{pid} = $pid;
            return $Result;
        }
    }

    if (defined $Stdin) {
        open SAVE_STDIN, "<&STDIN";
        print SAVE_STDIN if 0;          # keep "perl -w" happy
        close STDIN;
        open STDIN, "<$Stdin" or die "${Stdin}: $!\n";
    }
    if (defined $Min_Time) {
        @before = POSIX::times;
    }
    $system_result = system @args;
    Debug "system_result = $system_result\n";
    if (defined $Min_Time) {
        @after = POSIX::times();
    }
    if (defined $Stdin) {
        open STDIN, "<&SAVE_STDIN";
        unlink $Stdin if $Stdin_Is_Temporary;
    }

    #
    # Emulate csh "time" command
    #
    if (defined $Min_Time) {
        my $elapsed_ticks    =  $after[0] - $before[0];
        my $user_CPU_ticks   = ($after[1] - $before[1]) +   # this process
                               ($after[3] - $before[3]);    # child processes
        my $system_CPU_ticks = ($after[2] - $before[2]) +   # this process
                               ($after[4] - $before[4]);    # child processes

        my $percent_usage;
        if ($elapsed_ticks == 0) {
            $percent_usage = 0.0;
        }
        else {
            $percent_usage = ($user_CPU_ticks + $system_CPU_ticks)
                             / $elapsed_ticks * 100;
        }

        my $elapsed_seconds    = $elapsed_ticks    / $CLK_TCK;
        my $user_CPU_seconds   = $user_CPU_ticks   / $CLK_TCK;
        my $system_CPU_seconds = $system_CPU_ticks / $CLK_TCK;

        if ($elapsed_seconds >= $Min_Time) {
            printf "%.2fu %.2fs %s %.1f%%\n",
                   $user_CPU_seconds,
                   $system_CPU_seconds,
                   Elapsed_Time_Image $elapsed_seconds,
                   $percent_usage;
        }
    }
    if ($Background) {
        exit;
    }
    elsif (defined $User) {
        #
        # This is the child process; bail out and let the parent handle
        # the consequences.  Try to arrange for $? after the parent's
        # call to waitpid to match what it would have been if the parent
        # had called system.
        #
        my $Result = Get_Result $system_result, 0;
        if (defined $Result->{signal}) {
            Debug "Child: kill $Result->{signal}, $$\n";
            kill $Result->{signal}, $$;
        }
        else {
            Debug "Child: exit $Result->{status}\n";
            exit $Result->{status};
        }
    }

    return Get_Result $system_result, $Check;
} # Execute

# ----------------------------------------------------------------------

#
# Confirm that the necessary services are specified in
# /etc/services (or the NIS equivalent).
#
sub Check_Services() {
    my %expected_name = ( 2119 => 'gsigatekeeper',
                          2135 => 'gris',
                          2811 => 'gsiftp' );
    my @errors = ();
    foreach my $port (sort keys %expected_name) {
        my @serv = getservbyport $port, 'tcp';
        if (not @serv) {
            push @errors,
                 "    No service on port $port, " .
                 "expected $expected_name{$port}\n";
        }
        elsif ($serv[0] ne $expected_name{$port}) {
            push @errors,
                 "    Service on port $port is \"$serv[0]\", ",
                  "should be \"$expected_name{$port}\"\n";
        }
    }
    if (@errors) {
        push @manual_steps,
             "Correct /etc/services or equivalent:\n" .
             join('', @errors);
    }
} # Check_Services

# ----------------------------------------------------------------------

#
# Calls to die() cause this function to be called before exiting.
# Clean up temporary directory.
#
sub Die_Handler($) {
    if ($Cleanup and defined $working_dir) {
        print ">>> Cleaning up\n";
        chdir '/tmp';
        Execute @As_Root, 'rm', '-rf', $working_dir;
    }
    print Time_Image time, "\n";
} # Die_Handler

# ----------------------------------------------------------------------

#
# Given a time, return an ASCII UTC timestamp suitable for use
# in a file name, such as "2002-08-16-183304".
#
sub Timestamp_Of($) {
    my($time) = @_;
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
        gmtime($time);
    return sprintf "%04d-%02d-%02d-%02d%02d%02d",
                   $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
} # Timestamp_Of

# ----------------------------------------------------------------------

#
# Rename the specified file by appending its last modification time to
# its name.  Do nothing if file doesn't exist.  May be used on directories
# as well as ordinary files.
#
sub Backup($) {
    my($filename) = @_;
    my @stat;

    return if not -e $filename;
    @stat = stat $filename or die "${filename}: $!\n";
    my $timestamp = Timestamp_Of $stat[9]; # mtime
    my $new_name = "$filename-$timestamp";
    rename $filename, $new_name or die "$new_name: $!\n";
} # Backup

# ----------------------------------------------------------------------

sub Test_File_Creation() {
    print ">>> File creation test\n";
    print "\$<=$< \$>=$> \$(=\"$(\" \$)=\"$)\"\n";
    my $file1 = "$working_dir/test-file-1";
    my $file2 = "$working_dir/test-file-2";
    open FILE1, ">$file1";
    close FILE1;
    system 'touch', $file2;
    system 'ls', '-lsF', $file1, $file2;
    unlink $file1, $file2;
} # Test_File_Creation

# ----------------------------------------------------------------------

sub Inet_Config_Text($$) {
    my($daemon, $service) = @_;

    if ("$daemon/$service" eq 'xinetd/gsigatekeeper') {
        return <<"EOF";
service gsigatekeeper
{
    socket_type  = stream
    protocol     = tcp
    wait         = no
    user         = root
    server       = $Config{GLOBUS_LOCATION}/sbin/globus-gatekeeper
    server_args  = -conf $Config{GLOBUS_LOCATION}/etc/globus-gatekeeper.conf
    disable      = no
}
EOF
    }
    elsif ("$daemon/$service" eq 'xinetd/gsiftp') {
        return <<"EOF";
service gsiftp
{
    instances               = 1000
    socket_type             = stream
    wait                    = no
    user                    = root
    server                  = $Config{GLOBUS_LOCATION}/sbin/in.ftpd
    server_args             = -l -a -G /usr/nmi
    log_on_success         += DURATION USERID
    log_on_failure         += USERID
    nice                    = 10
    disable                 = no
}
EOF
    }
    elsif ("$daemon/$service" eq 'inetd/gsigatekeeper') {
        return "gsigatekeeper   stream tcp nowait root " .
               "$Config{GLOBUS_LOCATION}/sbin/globus-gatekeeper " .
               "globus-gatekeeper " .
               "-conf $Config{GLOBUS_LOCATION}/etc/globus-gatekeeper.conf\n";
    }
    elsif ("$daemon/$service" eq 'inetd/gsiftp') {
        return "gsiftp  stream  tcp     nowait  root    " .
               "$Config{GLOBUS_LOCATION}/sbin/in.ftpd in.ftpd -l -a\n";
    }
    else {
        die "Internal error, bad arguments to Inet_Config_Text()\n" .
            "    daemon=\"$daemon\", service=\"$service\"\n";
    }
} # Inet_Config_Text

# ----------------------------------------------------------------------

sub Image($) {
    my($arg) = @_;
    if (defined $arg) {
        $arg =~ s/\n/\\n/g;
        return "\"$arg\"";
    }
    else {
        return 'undef';
    }
} # Image

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Debugging;
} # Debug

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options] config_file
    -help               Display this message and exit.
    -validate-only      Validate the configuration file and exit.
    -cleanup            Delete temporary directory on completion (default).
    -postinstall        Run gpt-postinstall (default).
    -startup            Update system files and start services (default).
    -gpt-verbose        Pass -verbose option to gpt-install and/or gpt-build.
    -gpt-log            DISABLED.
                        Pass -log=... option to gpt-build.
                        Implies -nocleanup, since logs are written to the
                        temporary directory.
                        Doesn't affect binary installations (gpt-install).
    -gpt-install-only   Pass -install-only option to gpt-build.
                        Doesn't affect binary installations (gpt-install).
    -gpt-ignore-errors  Ignore errors from gpt-install and gpt-build.
    -debugging          Enable debugging.
Most options can be negated by prepending "no".
For example, "-nocleanup" inhibits cleanup.
EOF
    exit 1;
} # Usage
