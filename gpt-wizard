#!/usr/bin/perl -w

# $Id: gpt-wizard,v 1.248 2004-03-07 19:35:42-08 kst Exp $
# $Source: /home/kst/CVS_smov/tools/gpt-wizard/gpt-wizard,v $

########################################################################
# @Copyright@
# 
# Copyright (c) 2004 The Regents of the University of California. All
# rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
# 1. Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# 3. All advertising materials mentioning features or use of this
# software must display the following acknowledgement: This product
# includes software developed by the Grid and Cluster Computing Group
# at the San Diego Supercomputer Center and its contributors.
# 
# 4. Neither the name of the Center nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
# IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# @Copyright@
########################################################################

########################################################################
# Developed by Keith Thompson <kst@sdsc.edu>
########################################################################

#
# TO DO:
#
#     Start services other than GRIS (make it configurable).
#
#     May need to update lines in inetd.conf or files in xinetd.d
#     for services other than gsigatekeeper and gsiftp.
#
#     Automatically set up to report to one or more GIIS servers.
#     Configure this.
#
#     Be smarter about tarballs.  Handle .tar, .tar.gz, .tgz,
#     .tar.bz2.  Auto-detect what tar can handle (check output
#     of "tar --help") and fall back to gzip/bzip2 and pipes.
#     (Particularly useful for non-Linux systems.)
#
#     Smarter handling of flavors for source installations,
#     particularly for vendorcc; see build-gt2.
#
#     Detect 64-bit machines other than ia64.
#     If it's configurable, configure it.
#
#     Optionally use "setup-gsi -nonroot".  This should install the
#     Globus security stuff in $GLOBUS_LOCATION/etc.  This is useful
#     for a client-only installation.
#
#     Possibly make "setup-gsi" optional, configure /etc/grid-security
#     by brute force.  Find out more about the implications of doing this.
#
#     Optionally allow use of an existing /etc/grid-security directory.
#     If this option is not selected, warn (or die?) if one already
#     exists.
#
#     Allow GPT to be installed from an RPM or binary package.
#
#     Deal with globus-host-ssl.conf.42864e48
#               globus-user-ssl.conf.42864e48
#               grid-security.conf.42864e48
#
#     Optionally generate a Bourne shell script to do the installation
#     rather than actually doing the installation.  Low priority.
#
#     chown -R condor.condor $GLOBUS_LOCATION/var/condor
#     (or something like that)
#     *if* it exists, and there's a "condor" user (and group?
#     -- or just use user condor's default group).
#     I've seen problems with the condor daemons not being able to
#     write their log files.  For now, we mention it in @manual_steps.
#
#     Currently, if INSTALLER_USER is not root, the GSI-OpenSSH
#     postinstall script can't read the ssh private host keys,
#     so it generates new keys.  Copy the keys from /etc/ssh to
#     $GLOBUS_LOCATION/etc/ssh.  Do this only if there are newly generated
#     keys in $G_L/etc/ssh *and* we can read the keys in /etc/ssh;
#     also allow (maybe) for the keys being somewhere other than /etc/ssh.
#     On the other hand, it probably makes more sense to use symlinks
#     (which avoids the need to localize the etc/ssh subdirectory.)
#
#     The NCSA CA bundle has an interactive postinstall.  Consider
#     editing it to make it non-interactive.  In the documentation, warn
#     about the possibility of other interactive postinstall scripts --
#     and discourage developers from writing them.
#
#     Warn if directory name contains "bundle" and package file name
#     doesn't; mention that this may not apply to newer GPT releases.
#
#     In man page, clarify that "BUNDLE" can be either a bundle or a
#     package.  Consider a new config var PACKAGE, and enforce the
#     distinction between bundles and packages.  Add a section with
#     an overview of gpt, particularly the distinction between bundles
#     and packages (and mention rpms).
#
#     Support adding updates to an existing installation, including
#     adding information to the $GLOBUS_LOCATION/.gpt-wizard directory.
#
#     For updates, figure out how to apply options (particularly
#     "-static") depending on how the package was initially built.
#
#     Take another look for the scripts on which Fix_Setup_Script
#     is invoked.  Drop any that are no longer relevant.
#
#     In Get_Config(), bail out after, say, 100 errors (so it doesn't
#     go insane when I feed it a multi-megabyte log file rather than a
#     config file).
#
#     gpt-build has an option:
#         -installdir=path_to_installation  Override $GLOBUS_LOCATION
#     gpt-install has the same thing.
#     Add support for this.
#     (Actually, you can do it now with "option=-installdir=...")
#     [later] I tried this with myproxy, and it failed.
#

require 5.004;

use strict;

use File::Basename ();
use Getopt::Long ();
use POSIX ();

sub Strip_Revision_String($);
sub Get_Config($);
sub Get_System_Information();
sub Elapsed_Time_Image($);
sub Time_Image($);
sub Make_Temp_File($);
sub Get_Result($$);
sub Get_Update_Flavors($);
sub Execute(@);
sub Check_Services();
sub Cleanup();
sub Die_Handler($);
sub Signal_Handler($);
sub Timestamp_Of($);
sub Backup($);
sub Is_Empty_Dir($);
sub Fix_Setup_Script($);
sub Inet_Config_Text($$);
sub Manual_Steps_Text(@);
sub Find_Command($$);
sub Image($);
sub Show_Version();
sub Release_String();
sub Debug(@);
sub Usage(@);

#
# Make warnings fatal.
#
$SIG{__WARN__} = sub { die @_ };

$| = 1;

my $Release_Number   = '0.6.1'; # most recent release
my $Release_Revision = '1.239'; # RCS/CVS revision of most recent release

my @Saved_ARGV        = @ARGV;
my $Program_Name      = File::Basename::basename $0;
my $Revision          = Strip_Revision_String '$Revision: 1.248 $';
my $Help              = undef;
my $Show_Version      = undef;
my $Validate_Only     = undef;
my $Debugging         = undef;
my $Cleanup           = 1;
my $Postinstall       = 1;
my $Startup           = undef;
my $GPT_Verbose       = undef;
my $GPT_Log           = undef;
my $GPT_Install_Only  = undef;
my $GPT_Ignore_Errors = undef;
my $AIX_Kludge        = undef;
my @Opts = ( 'help!'              => \$Help,
             'version!'           => \$Show_Version,
             'validate-only!'     => \$Validate_Only,
             'debugging!'         => \$Debugging,
             'cleanup!'           => \$Cleanup,
             'postinstall!'       => \$Postinstall,
             'startup!'           => \$Startup,
             'gpt-verbose!'       => \$GPT_Verbose,
           # 'gpt-log!'           => \$GPT_Log,
             'gpt-install-only!'  => \$GPT_Install_Only,
             'gpt-ignore-errors!' => \$GPT_Ignore_Errors,
             'aix-kludge!'        => \$AIX_Kludge );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $Help;
Show_Version if $Show_Version;

die "-gpt-log option is disabled\n" if $GPT_Log;

if ($GPT_Log and $Cleanup) {
    print "-gpt-log implies -nocleanup, setting option\n";
    $Cleanup = undef;
}

if ($Startup and not $Postinstall) {
    Usage "Option conflict: \"-startup\" and \"-nopostinstall\"\n",
          "    (Can't do startup without doing gpt-postinstall)\n";
}

$SIG{__DIE__} = \&Die_Handler;
$SIG{INT}     = \&Signal_Handler;
$SIG{TERM}    = \&Signal_Handler;

my $Running_As_Root = ($< == 0);
my $This_User  = (getpwuid($<))[0];
my $This_Group = (getgrgid($())[0]; # ')' to make vi paren-matching happy
my $Default_User  = ( $Running_As_Root ? 'globus' : $This_User  );
my $Default_Group = ( $Running_As_Root ? 'globus' : $This_Group );

my %Running = (); # Keys are PIDs of processes spawned by Execute.

if ($Startup and not $Running_As_Root) {
    die "The -startup option can only be used by root\n";
}

my $tar = undef; 
my $gzip = undef; 

my $temp_file_serial_number = 0;

my @manual_steps = ();

Usage if scalar @ARGV != 1;
my $Config_File = $ARGV[0];
my $Config_File_Processed = 0;
my %Config = Get_Config $Config_File;
$Config_File_Processed = 1;

my %Sys = Get_System_Information;

my $Config_File_Full_Path;
if ($Config_File =~ /^\//) {
    $Config_File_Full_Path = $Config_File;
}
else {
    my $pwd = `pwd`;
    chomp $pwd;
    $Config_File_Full_Path = "$pwd/$Config_File";
}

#
# If any bundles were installed using RPM, we'll need to run
# gpt-postinstall as root.
#
my $Using_RPM = 0;

if ($Sys{LC_OSNAME} eq 'linux') {
    # ok
}
elsif ($Sys{LC_OSNAME} eq 'sunos' or
       $Sys{LC_OSNAME} eq 'aix') {
    if ($Startup) {
        die "The \"-startup\" option is not currently supported " .
            "on $Sys{OSNAME}\n";
    }
}
else {
    die "Unsupported OS \"$Sys{OSNAME}\"\n" .
        "Please contact Keith Thompson <kst\@sdsc.edu> for information\n";
}

Check_Services;

my @As_Root      = qw(-time=5 -verbose -check);
my @As_Installer = qw(-time=5 -verbose -check);
my @As_Root_GPT      = @As_Root;
my @As_Installer_GPT = @As_Installer;
if ($GPT_Ignore_Errors) {
    @As_Root_GPT      = grep { $_ ne '-check' } @As_Root;
    @As_Installer_GPT = grep { $_ ne '-check' } @As_Installer;
}
if ($Running_As_Root) {
    push @As_Installer,
         "-user=$Config{INSTALLER_USER}.$Config{INSTALLER_GROUP}";
    push @As_Installer_GPT,
         "-user=$Config{INSTALLER_USER}.$Config{INSTALLER_GROUP}";
}
else {
    my $error_arg = '-error=Internal error, non-root attempting to run as root';
    push @As_Root,     $error_arg;
    push @As_Root_GPT, $error_arg;
}
my @As_Myself = ( $Running_As_Root ? @As_Root : @As_Installer );

my $CLK_TCK = POSIX::sysconf(&POSIX::_SC_CLK_TCK);

exit 0 if $Validate_Only;

########################################################################
# Create a temporary working directory and set some variables.
########################################################################

my $build_info = Time_Image(time) . "\n";
$build_info .= "$Program_Name revision $Revision processing $Config_File";
if (defined $Config{CONFIG_FILE_REVISION}) {
    $build_info .= " $Config{CONFIG_FILE_REVISION}\n";
}
else {
    $build_info .= ", no CONFIG_FILE_REVISION specified\n";
}
$build_info .= "Command-line arguments:\n";
foreach my $arg (@Saved_ARGV) {
    $build_info .= "    $arg\n";
}
print $build_info;

my @installer_pw = getpwnam $Config{INSTALLER_USER};
die ">>> No user $Config{INSTALLER_USER}\n" unless $#installer_pw >= 2;
my @installer_gr = getgrnam $Config{INSTALLER_GROUP};
die ">>> No group $Config{INSTALLER_GROUP}\n" unless $#installer_gr >= 2;
my $installer_uid = $installer_pw[2];
my $installer_gid = $installer_gr[2];
# die ">>> installer_uid = $installer_uid\n" unless $installer_uid > 0;
# die ">>> installer_gid = $installer_gid\n" unless $installer_gid > 0;

print "% setting PATH=$Config{PATH}\n";
$ENV{PATH} = $Config{PATH};

foreach my $env (@{$Config{ENV}}) {
    my($name, $value);
    if ($env =~ /^([^=]+)=(.*)$/) {
        ($name, $value) = ($1, $2);
    }
    elsif ($env =~ /^[^=]*$/) {
        die "Invalid ENV option: \"$env\"\n";
    }
    else {
        $name = $env;
        $value = '';
    }
    print "% setting $name=\"$value\"\n";
    $ENV{$name} = $value;
}

print "% umask $Config{UMASK}\n";
umask oct $Config{UMASK} or die "umask $Config{UMASK}: $!\n";

my $working_dir = "$Config{TEMP_DIR}/gpt-wizard-" . time . "-$$";
print "% mkdir $working_dir\n";
mkdir $working_dir, 0700 or die "$working_dir: $!\n";
if ($Running_As_Root) {
    chown $installer_uid, $installer_gid, $working_dir
        or die "$working_dir: $!\n";
}
print "% cd $working_dir\n";
chdir $working_dir or die "$working_dir: $!\n";
if (not $Cleanup) {
    push @manual_steps,
         "The working directory\n" .
         "    $working_dir\n" .
         "is likely to be taking up a lot of disk space.  Clean it up\n" .
         "when you're done with it.\n";
}

########################################################################
# Set the $GLOBUS_HOSTNAME environment variable if specified.
# This is necessary if the system hostname doesn't match the
# externally visible network name (e.g., on a typical Rocks cluster).
########################################################################
if (defined $Config{GLOBUS_HOSTNAME}) {
    print "% Setting GLOBUS_HOSTNAME=$Config{GLOBUS_HOSTNAME}\n";
    $ENV{GLOBUS_HOSTNAME} = $Config{GLOBUS_HOSTNAME};
}

########################################################################
# Install GPT
########################################################################

########################################
# Unpack the source tarball.  See what the tar command created.
# If there's exactly one new thing in the current directory, assume it's
# the extracted source directory.
########################################

if (not $AIX_Kludge) {
    opendir DIR, '.' or die ".: $!\n";
    my @files_before = readdir DIR;
    closedir DIR;
    my %already_existed = map { $_ => 1 } @files_before;
    my @errors = ();

    if (not defined $gzip) {
        $gzip = Find_Command 'gzip', $Config{GZIP};
    }
    push @errors, "No gzip command found\n" if not defined $gzip;
    if (not defined $tar) {
        $tar = Find_Command 'tar', $Config{TAR};
    }
    push @errors, "No tar command found\n" if not defined $tar;
    die @errors if @errors;
    # Execute @As_Installer, 'tar', 'zxf', $Config{GPT_TARBALL};
    Execute @As_Installer, '/bin/sh', '-c',
            "$gzip -d < $Config{GPT_TARBALL} | $tar xf -";

    opendir DIR, '.' or die ".: $!\n";
    my @files_after = readdir DIR;
    closedir DIR;

    my @new_files = ();
    foreach my $file (@files_after) {
        push @new_files, $file if not $already_existed{$file};
    }

    if (scalar @new_files == 0) {
        die "Can't determine GPT source directory, " .
            "tar didn't create anything\n";
    }
    elsif (scalar @new_files == 1) {
        my $src_dir = $new_files[0];
        print "% cd $working_dir/$src_dir\n";
        chdir "$working_dir/$src_dir" or die "$working_dir/$src_dir: $!\n";
    }
    else {
        die "Can't determine GPT source directory, tar created (@new_files)\n";
    }
}

########################################
# Create the $GPT_LOCATION directory.
########################################
print "% Setting GPT_LOCATION=$Config{GPT_LOCATION}\n";
$ENV{GPT_LOCATION} = $Config{GPT_LOCATION};

if ($AIX_Kludge) {
    die "No directory $Config{GPT_LOCATION}\n"
        if not -d $Config{GPT_LOCATION};
    die "No executable $Config{GPT_LOCATION}/sbin/gpt-install\n"
        if not -x "$Config{GPT_LOCATION}/sbin/gpt-install";
}
else {
    if (not -d $Config{GPT_LOCATION}) {
        print "% mkdir $Config{GPT_LOCATION}\n";
        mkdir $Config{GPT_LOCATION}, 0777 or die "$Config{GPT_LOCATION}: $!\n";
        if ($Running_As_Root) {
            chown $installer_uid, $installer_gid, $Config{GPT_LOCATION}
                or die "$Config{GPT_LOCATION}: $!\n";
        }
    }
}

########################################
# Run build_gpt to install GPT
########################################
if (not $AIX_Kludge) {
    #
    # The default setting for the $LANG environment variable
    # on Red Hat 9 causes problems building some Perl modules.
    # See <https://bugzilla.ncsa.uiuc.edu/show_bug.cgi?id=131>
    #
    delete $ENV{LANG};
    Execute @As_Installer, './build_gpt';

    print "% cd $working_dir\n";
    chdir $working_dir or die "$working_dir: $!\n";
}

########################################
# <http://www.nsf-middleware.org/documentation/GPT/index.htm>
# says to delete these two files.  They seem to be installed
# if you use the RPM, but not if you use the source tarball.
# So in reality, these files probably won't exist in the first place;
# ignore any errors from unlink().
########################################
unlink '/etc/profile.d/gpt.sh',
       '/etc/profile.d/gpt.csh';

########################################################################
# Confirm GPT installation
########################################################################
#
# In older GPT releases, the gpt-build and gpt-install commands
# are called globus-build and globus-install.
#
my $gpt_install_command = undef;
my $gpt_build_command   = undef;
my $sbin_dir = "$Config{GPT_LOCATION}/sbin";

if (-x "$sbin_dir/gpt-install" and -x "$sbin_dir/gpt-build") {
    $gpt_install_command = "$sbin_dir/gpt-install";
    $gpt_build_command   = "$sbin_dir/gpt-build";
}
elsif (-x "$sbin_dir/globus-install" and -x "$sbin_dir/globus-build") {
    die "gpt-wizard no longer supports GPT release 1\n",
        "Use GPT release 2 or higher.\n";
}
else {
    die "Can't find install and build commands in $sbin_dir\n";
}

#
# Verify GPT installation by verifying that "gpt-install -version"
# succeeds.
#
Execute @As_Installer, $gpt_install_command, '-version';

########################################################################
# Install bundles (presumably Globus et al)
########################################################################

########################################
# Create the $GLOBUS_LOCATION directory (unless $GLOBUS_LOCATION and
# $GPT_LOCATION are the same; in that case, it already exists.)
########################################
print "% Setting GLOBUS_LOCATION=$Config{GLOBUS_LOCATION}\n";
$ENV{GLOBUS_LOCATION} = $Config{GLOBUS_LOCATION};
if ($Config{GLOBUS_LOCATION} ne $Config{GPT_LOCATION} and
    not -e $Config{GLOBUS_LOCATION})
{
    print "% mkdir $Config{GLOBUS_LOCATION}\n";
    mkdir $Config{GLOBUS_LOCATION}, 0777
        or die "$Config{GLOBUS_LOCATION}: $!\n";
    if ($Running_As_Root) {
        chown $installer_uid, $installer_gid, $Config{GLOBUS_LOCATION}
            or die "$Config{GLOBUS_LOCATION}: $!\n";
    }
}

########################################
# Create a $GLOBUS_LOCATION/.gpt-wizard directory, to contain information
# about the build, including a copy of the config file.
########################################
my $info_dir = "$Config{GLOBUS_LOCATION}/.gpt-wizard";
my $info_file = "$info_dir/info";

print "% mkdir $info_dir\n";
mkdir $info_dir, 0777 or die "$info_dir: $!\n";
if ($Running_As_Root) {
    chown $installer_uid, $installer_gid, $info_dir or die "$info_dir: $!\n";
}

Execute @As_Installer, 'cp', '-p', $Config_File_Full_Path, "$info_dir/.";

open INFO, ">$info_file" or die "$info_file: $!\n";
print INFO $build_info;
close INFO;

########################################
# Run gpt-install or gpt-build to install the bundles.
########################################
foreach my $bundle ( @{$Config{BUNDLE}}, @{$Config{UPDATE}} ) {
    my $bundle_basename = File::Basename::basename $bundle->{filename};

    #
    # If the file name was specified in the config file with a
    # "kind=binary" attribute, treat it as a binary bundle (use
    # gpt-install).
    #
    # If it was specified with a "kind=source" suffix, treat it as a
    # source bundle (use gpt-build).
    #
    # If it was specified with a "kind=rpm" suffix, treat it as an RPM
    # bundle (use gpt-install, and run it as root).
    #
    # If no "kind" attribute was specified:
    #      If it's an update, assume it's source.
    #      If the file name contains the word "rpm", assume it's an
    #      RPM bundle.
    #      Otherwise, if the file name contains the word "src" assume
    #      it's a source bundle.
    #      Otherwise, assume it's a binary bundle.
    #
    # This is arguably too complicated; consider making the "kind"
    # attribute mandatory, at least for non-updates.
    #
    my $bundle_kind = ${bundle}->{kind};
    if (not defined $bundle_kind) {
        if ($bundle->{is_update}) {
            $bundle_kind = 'source';
        }
        elsif ($bundle_basename =~ /(\b|_)src(\b|_)/) {
            $bundle_kind = 'source';
        }
        elsif ($bundle_basename =~ /(\b|_)rpm(\b|_)/) {
            $bundle_kind = 'rpm';
        }
        else {
            $bundle_kind = 'binary';
        }
    }

    if ($bundle_kind eq 'source') {
        #
        # Using gpt-build to build and install a source bundle.
        #
        my @options = ();
        if ($GPT_Verbose) {
            push @options, '-verbose';
        }
        if ($GPT_Log) {
            my $logfile = File::Basename::basename $bundle . ".log";
            push @options, "-log=$logfile";
        }
        if ($GPT_Install_Only) {
            push @options, '-install-only';
        }
        if ($bundle->{is_update}) {
            push @options, '-update';
        }
        if (defined $bundle->{option}) {
            push @options, split(',', $bundle->{option});
        }

        my @flavors = ();
        if (defined $bundle->{flavor}) {
            @flavors = split /,/, $bundle->{flavor};
        }
        elsif ($bundle->{is_update}) {
            @flavors = Get_Update_Flavors $bundle->{filename};
        }
        else {
            push @options, '-std-flavors';
        }
        Execute @As_Installer_GPT,
                $gpt_build_command, @options, $bundle->{filename}, @flavors;
    }
    elsif ($bundle_kind eq 'binary' or $bundle_kind eq 'rpm') {
        #
        # Using gpt-install to install a binary or RPM bundle.
        #
        my @options = ();
        if ($GPT_Verbose) {
            push @options, '-verbose';
        }
        if (defined $bundle->{option}) {
            push @options, split(',', $bundle->{option});
        }
        #
        # $GPT_Log and $GPT_Install_Only are inapplicable for gpt-install.
        #
        if ($bundle_kind eq 'binary') {
            Execute @As_Installer_GPT,
                    $gpt_install_command, @options, $bundle->{filename};
        }
        else {
            $Using_RPM = 1;
            Execute @As_Root_GPT,
                    $gpt_install_command, @options, $bundle->{filename};
        }
    }
    else {
        #
        # The missing "\n" in the error message is deliberate.  It causes
        # Perl to print more information about the location of the error.
        #
        die "Internal error, \$bundle_kind = \"$bundle_kind\"";
    }
}

########################################
# A binary installation does not include the globus_config.h header
# file.  It must be generated with "gpt-build -nosrc <flavors>".
#
# We need to determine the set of flavors for which this is needed.
# Method: For each subdirectory of $GLOBUS_LOCATION/include, if the
# subdirectory contains globus_common.h but not globus_config.h, add
# the subdirectory name to the list of flavors.
########################################
my @nosrc_flavors = ();
my $include_dir = "$ENV{GLOBUS_LOCATION}/include";
if (-d $include_dir) {
    opendir DIR, $include_dir or die "$include_dir: $!\n";
    my @subdirs = sort
                      grep { $_ ne '.' and
                             $_ ne '..' and
                             -d "$include_dir/$_" }
                          readdir DIR;
    foreach my $subdir (@subdirs) {
        if (-e "$include_dir/$subdir/globus_common.h" and
            not -e "$include_dir/$subdir/globus_config.h")
        {
            push @nosrc_flavors, $subdir;
        }
    }
    if (@nosrc_flavors) {
        Execute @As_Installer_GPT,
                $gpt_build_command, '-nosrc', @nosrc_flavors;
    }
}

########################################
# If GLOBUS_LOCAL_DIRECTORY is defined in the config file, make
# $GLOBUS_LOCATION/var and $GLOBUS_LOCATION/tmp symlinks into it (after
# copying them if they exists, or creating them if they doesn't).
# Likewise for certain files under $GLOBUS_LOCATION/etc.
#
# Certain subdirectories and files must be on local filesystems,
# so root can write to logs and so forth.  See Globus Bugzilla #660,
# <http://bugzilla.globus.org/bugzilla/show_bug.cgi?id=660>.
########################################
if (defined $Config{GLOBUS_LOCAL_DIRECTORY}) {
    if (not -d $Config{GLOBUS_LOCAL_DIRECTORY}) {
        print "% mkdir $Config{GLOBUS_LOCAL_DIRECTORY}\n";
        mkdir $Config{GLOBUS_LOCAL_DIRECTORY}, 0777
            or die "$Config{GLOBUS_LOCAL_DIRECTORY}: $!\n";
        if ($Running_As_Root) {
            chown $installer_uid,
                  $installer_gid,
                  $Config{GLOBUS_LOCAL_DIRECTORY}
                or die "$Config{GLOBUS_LOCAL_DIRECTORY}: $!\n";
        }
    }

    foreach my $subdir ('var', 'tmp') {
        my $global_dir = "$Config{GLOBUS_LOCATION}/$subdir";
        my $local_dir  = "$Config{GLOBUS_LOCAL_DIRECTORY}/$subdir";

        if (-d $global_dir) {
            Execute @As_Myself, 'cp', '-pr', $global_dir, $local_dir;
            Execute @As_Myself, 'rm', '-rf', $global_dir;
        }
        else {
            print "% mkdir $local_dir\n";
            mkdir $local_dir, 0777 or die "$local_dir: $!\n";
            if ($Running_As_Root) {
                chown $installer_uid, $installer_gid, $local_dir
                    or die "$local_dir: $!\n";
            }
        }
        symlink $local_dir, $global_dir or die "$global_dir: $!\n";
    }

    my $local_etc  = "$Config{GLOBUS_LOCAL_DIRECTORY}/etc";

    print "% mkdir $local_etc\n";
    mkdir $local_etc, 0777 or die "$local_etc: $!\n";
    if ($Running_As_Root) {
        chown $installer_uid, $installer_gid, $local_etc
            or die "$local_etc: $!\n";
    }
}

########################################################################
# Post-installation
########################################################################

########################################
# Edit certain setup files so they don't prompt for user input.  Ugly,
# but it beats guessing what they're going to want (and in what order
# they'll be run).
########################################

Fix_Setup_Script
    "$ENV{GLOBUS_LOCATION}/setup/globus/grid-security-config.in";
Fix_Setup_Script
    "$ENV{GLOBUS_LOCATION}/setup/globus/setup-ssl-utils.pl";
Fix_Setup_Script
    "$ENV{GLOBUS_LOCATION}/setup/kca/setup-kca.pl";
Fix_Setup_Script
    "$ENV{GLOBUS_LOCATION}/setup/gsi_openssh_setup/setup-openssh.pl";

########################################
# Allow a specified command to be executed before running gpt-postinstall.
# This is used on AIX to run mds-aix-relink.sh, which works around some
# AIX-specific libtool problems.  It's a bit of a kludge, not to be used
# unless it's necessary.  Just to make it even kludgier, any occurrence of
# the string BUILD_DIR is replaced with the name of the build directory.
########################################
if ($Postinstall and defined $Config{PRE_POSTINSTALL}) {
    my $pre_postinstall = $Config{PRE_POSTINSTALL};
    $pre_postinstall =~ s(BUILD_DIR)($working_dir/BUILD);
    my @fixup_command = split /\s+/, $pre_postinstall;
    Execute @As_Installer, @fixup_command;
}

########################################
# Run gpt-postinstall.
########################################
if ($Postinstall) {
    Execute $Using_RPM ? @As_Root : @As_Installer,
            "$Config{GPT_LOCATION}/sbin/gpt-postinstall";
}
else {
    push @manual_steps,
         "Run $Config{GPT_LOCATION}/sbin/gpt-postinstall\n";
}

########################################
# Localize certain files under $GLOBUS_LOCATION/etc
# See Globus Bugzilla #660,
# <http://bugzilla.globus.org/bugzilla/show_bug.cgi?id=660>.
########################################
my @localized_etc_files = qw( globus-job-manager.conf
                              grid-info-resource-ldif.conf
                              grid-info-resource-register.conf
                              grid-info-site-policy.conf
                              grid-info-slapd.conf );
if (defined $Config{GLOBUS_LOCAL_DIRECTORY}) {
    my $global_etc = "$Config{GLOBUS_LOCATION}/etc";
    my $local_etc  = "$Config{GLOBUS_LOCAL_DIRECTORY}/etc";  
    if ($Postinstall) {
        my @missing = ();
        foreach my $file ( @localized_etc_files ) {
            if (-e "$global_etc/$file") {
                Execute @As_Myself,
                        'cp', '-p', "$global_etc/$file", "$local_etc/$file";
                unlink "$global_etc/$file" or die "$global_etc/${file}: $!\n";
                symlink "$local_etc/$file", "$global_etc/$file"
                    or die "$global_etc/${file}: $!\n";
            }
            else {
                push @missing, $file;
            }
        }
        if (@missing) {
            push @manual_steps,
                 "Investigate missing files in\n" .
                 "$Config{GLOBUS_LOCATION}/etc :\n" .
                 join('', map("    $_\n", @missing));
        }
    }
    else {
        push @manual_steps,
             "After running gpt-postinstall, copy the following files:\n" .
             join('', map("    $_\n", @localized_etc_files)) .
             "from $global_etc\n" .
             "to $local_etc\n" .
             "and replace the originals with symbolic links\n";
    }
}

########################################
# Configure batch jobmanager (old style)
########################################
#
# This is obsolete as of Globus 2.2
#
if (defined $Config{BATCH_SYSTEM}) {
    Execute $Using_RPM ? @As_Root : @As_Installer,
        "$Config{GLOBUS_LOCATION}/setup/globus/setup-globus-gram-job-manager",
        "-type=$Config{BATCH_SYSTEM}";
    my $libexec = "$Config{GLOBUS_LOCATION}/libexec";
    push @manual_steps,
         "Fix $Config{GLOBUS_LOCATION}/libexec/" .
         "globus-script-$Config{BATCH_SYSTEM}-* if necessary\n";
}

########################################
# Configure batch jobmanager (new style)
########################################
if (defined $Config{JOB_MANAGER}) {
    my @args = split /\s+/, $Config{JOB_MANAGER};
    my $jobmanager = shift @args;
    my $setup_dir = "$Config{GLOBUS_LOCATION}/setup/globus";
    #
    # You have to be in the setup directory, because
    # setup-globus-job-manager-FOO.pl invokes "./find-FOO-tools"
    # (for FOO = pbs, lsf, etc.)  Argh!
    #
    if ($Postinstall) {
        chdir $setup_dir or die "$setup_dir: $!\n";
        Execute $Using_RPM ? @As_Root : @As_Installer,
            "$setup_dir/setup-globus-job-manager-$jobmanager",
            @args;
    }
    else {
        push @manual_steps,
             "After running gpt-postinstall, cd to\n" .
             "$setup_dir\n" .
             "and configure the $jobmanager jobmanager " .
             "by running the following command:\n" .
             "    ./globus-job-manager-$jobmanager @args\n" .
             "(You must be in the directory to run the command.)\n";
    }
}

########################################
# Run setup-gsi to create /etc/grid-security
# (but we're going to replace its contents in a moment).
########################################
if ($Startup) {
    Execute @As_Root,
            "$Config{GLOBUS_LOCATION}/setup/globus/setup-gsi";
}
else {
    push @manual_steps,
         "As root, run $Config{GLOBUS_LOCATION}/setup/globus/setup-gsi\n";
}

########################################
# Now copy files to /etc/grid-security.
########################################
if ($Startup) {
    if (defined $Config{GRID_MAPFILE}) {
        Backup '/etc/grid-security/grid-mapfile';
        Execute @As_Root,
                'cp', $Config{GRID_MAPFILE},
                      '/etc/grid-security/grid-mapfile';
        chmod 0444, '/etc/grid-security/grid-mapfile';
    }
    else {
        push @manual_steps,
             "Create /etc/grid-security/grid-mapfile, " .
             "mode 444, owned by root\n";
    }

    if (defined $Config{HOST_CERT}) {
        Backup '/etc/grid-security/hostcert.pem';
        Execute @As_Root,
                'cp', $Config{HOST_CERT}, '/etc/grid-security/hostcert.pem';
        chmod 0444, '/etc/grid-security/hostcert.pem';
    }
    else {
        push @manual_steps,
             "Create /etc/grid-security/hostcert.pem, " .
             "mode 444, owned by root\n";
    }

    if (defined $Config{HOST_KEY}) {
        Backup '/etc/grid-security/hostkey.pem';
        Execute @As_Root,
                'cp', $Config{HOST_KEY}, '/etc/grid-security/hostkey.pem';
        chmod 0400, '/etc/grid-security/hostkey.pem';
    }
    else {
        push @manual_steps,
             "Create /etc/grid-security/hostkey.pem, " .
             "mode 400, owned by root\n";
    }

    my $ldap_dir = '/etc/grid-security/ldap';

    if (defined $Config{LDAP_CERT}) {
        if (not -d $ldap_dir) {
            print "% mkdir $ldap_dir\n";
            mkdir $ldap_dir, 0777 or die "$ldap_dir: $!\n";
            print "% chown $Config{INSTALLER_USER}:$Config{INSTALLER_GROUP} " .
                   "$ldap_dir\n";
            chown $installer_uid, $installer_gid, $ldap_dir
                or die "$ldap_dir: $!\n";
        }
        Backup "$ldap_dir/ldapcert.pem";
        Execute @As_Installer,
                'cp', $Config{LDAP_CERT},
                      "$ldap_dir/ldapcert.pem";
        chmod 0444, "$ldap_dir/ldapcert.pem";
    }
    else {
        push @manual_steps,
             "Optionally create $ldap_dir/ldapcert.pem, ", 
             "mode 444, owned by $Config{INSTALLER_USER}\n";
    }

    if (defined $Config{LDAP_KEY}) {
        if (not -d $ldap_dir) {
            #
            # This is duplicated code (see above).  A bad idea, but I
            # haven't had time to restructure it yet.
            #
            print "% mkdir $ldap_dir\n";
            mkdir $ldap_dir, 0777 or die "$ldap_dir: $!\n";
            print "% chown $Config{INSTALLER_USER}:$Config{INSTALLER_GROUP} " .
                   "$ldap_dir\n";
            chown $installer_uid, $installer_gid, $ldap_dir
                or die "$ldap_dir: $!\n";
        }
        Backup "$ldap_dir/ldapkey.pem";
        Execute @As_Installer,
                'cp', $Config{LDAP_KEY},
                      "$ldap_dir/ldapkey.pem";
        chmod 0400, "$ldap_dir/ldapkey.pem";
    }
    else {
        push @manual_steps,
             "Optionally create $ldap_dir/ldapkey.pem, ", 
             "mode 400, owned by $Config{INSTALLER_USER}\n";
    }
}
else {
    push @manual_steps,
         "Set up /etc/grid-security directory.\n" .
         "Create /etc/grid-security/grid-mapfile,      mode 444, " .
         "owned by root\n" .
         "Create /etc/grid-security/hostcert.pem,      mode 444, " .
         "owned by root\n" .
         "Create /etc/grid-security/hostkey.pem,       mode 400, " .
         "owned by root\n" .
         "Create /etc/grid-security/ldap/ldapcert.pem, mode 444, " .
         "owned by $Config{INSTALLER_USER} (optional)\n" .
         "Create /etc/grid-security/ldap/ldapkey.pem,  mode 400, " .
         "owned by $Config{INSTALLER_USER} (optional)\n";
}

if ($Startup and defined $Config{CA_CERT_TARBALL}) {
    my $ca_cert_dir = '/etc/grid-security/certificates';
    Backup $ca_cert_dir;
    print "% mkdir $ca_cert_dir\n";
    mkdir $ca_cert_dir, 0777 or die "$ca_cert_dir: $!\n";
    print "% cd $ca_cert_dir\n";
    chdir $ca_cert_dir or die "$ca_cert_dir: $!\n";
    Execute @As_Root, 'tar', 'zxf', $Config{CA_CERT_TARBALL};
}
else {
    push @manual_steps,
         "Copy CA certificates and signing-policy files to\n" .
         "/etc/grid-security/certificates\n";
}

if (defined $Sys{NET_DAEMON} and $Sys{NET_DAEMON} eq 'xinetd') {
    my $xinetd_dir = '/etc/xinetd.d';
    my $gatekeeper_file = "$xinetd_dir/gsigatekeeper";
    my $gsiftp_file     = "$xinetd_dir/gsiftp";
    my $gatekeeper_text = Inet_Config_Text 'xinetd', 'gsigatekeeper';
    my $gsiftp_text     = Inet_Config_Text 'xinetd', 'gsiftp';
    if (not -d $xinetd_dir) {
        my $s = "You seem to be running xinetd";
        if (not defined $Sys{NET_DAEMON_PID}) {
            $s = "You seem to have xinetd on the system";
        }
        push @manual_steps,
             "$s,\n" .
             "but there is no $xinetd_dir directory.\n" .
             "$Program_Name is confused.\n";
    }
    else {
        if ($Startup and -d $xinetd_dir) {
            Backup $gatekeeper_file;
            open FILE, "> $gatekeeper_file" or die "${gatekeeper_file}: $!\n";
            print FILE $gatekeeper_text;
            close FILE;

            Backup $gsiftp_file;
            open FILE, "> $gsiftp_file" or die "${gsiftp_file}: $!\n";
            print FILE $gsiftp_text;
            close FILE;

            if (defined $Sys{NET_DAEMON_PID}) {
                Execute @As_Root, split / /, $Sys{NET_DAEMON_RELOAD};
            }
            else {
                push @manual_steps,
                     "xinetd is not running; start it\n";
                push @manual_steps,
                     "xinetd can be restarted by executing as root:\n" .
                     "$Sys{NET_DAEMON_RELOAD}\n";
            }
        }
        else {
            if (not defined $Sys{NET_DAEMON_PID}) {
                push @manual_steps,
                     "xinetd is not running; start it\n";
            }
            push @manual_steps,
                 "Set up xinetd scripts for gsigatekeeper and gsiftp:\n";
            push @manual_steps,
                 "Create the file\n" .
                 "    $gatekeeper_file\n" .
                 "with the following contents:\n" .
                 $gatekeeper_text;
            push @manual_steps,
                 "Create the file\n" .
                 "    $gsiftp_file\n" .
                 "with the following contents:\n" .
                 $gsiftp_text;
        }
    }
}
elsif (defined $Sys{NET_DAEMON} and $Sys{NET_DAEMON} eq 'inetd') {
    #
    # For inetd, we need to update /etc/inetd.conf.
    # Since this involves editing an existing file (which requires
    # some care about its previous contents), and some sites might
    # want to use things like tcpd, we'll let the user do this manually.
    #
    if (not defined $Sys{NET_DAEMON_PID}) {
        push @manual_steps, "inetd is not running; start it\n";
    }

    my $update = "Update /etc/inetd.conf:\n";

    $update .= "gsigatekeeper:\n";
    $update .= Inet_Config_Text 'inetd', 'gsigatekeeper';

    $update .= "gsiftp:\n";
    $update .= Inet_Config_Text 'inetd', 'gsiftp';

    $update .= "Allow for any site-specific conventions for /etc/inetd.conf\n";

    $update .= "Execute as root \"$Sys{NET_DAEMON_RELOAD}\"\n";
    push @manual_steps, $update;
}
elsif (defined $Sys{NET_DAEMON}) {
    die "Internal error \$Sys{NET_DAEMON} = \"$Sys{NET_DAEMON}\"";
}
else {
    push @manual_steps,
         "Unable to determine net daemon (inetd or xinetd)\n" .
         "Arrange for gsigatekeeper, gsiftp, and other daemons to execute\n";

    push @manual_steps,
         "For inetd, add the following lines to /etc/inetd.conf\n" .
         "(allowing for any site-specific conventions):\n" .
         Inet_Config_Text('inetd', 'gsigatekeeper') .
         Inet_Config_Text('inetd', 'gsiftp');

    push @manual_steps,
         "For xinetd, create the file /etc/xinetd.d/gsigatekeeper\n" .
         "with the following contents:\n" .
         Inet_Config_Text('xinetd', 'gsigatekeeper') .
         "and the file /etc/xinetd.d/gsiftp with the following contents:\n" .
         Inet_Config_Text('xinetd', 'gsiftp');
}

if ($Startup) {
    Execute @As_Installer,
            "$Config{GLOBUS_LOCATION}/sbin/SXXgris", 'start';
}
else {
    push @manual_steps,
         "As $Config{INSTALLER_USER} run " .
         "$Config{GLOBUS_LOCATION}/sbin/SXXgris start\n";
}

push @manual_steps,
     "Arrange for \"$Config{GLOBUS_LOCATION}/sbin/SXXgris start\"\n" .
     "to be executed by user \"$Config{INSTALLER_USER}\" on system boot\n";

push @manual_steps,
     "Start any other desired services\n";

push @manual_steps,
     "Configure to report to a GIIS server if desired\n";

if (-d "$Config{GLOBUS_LOCATION}/etc/ssh") {
    #
    # We installed GSI-OpenSSH
    #
    push @manual_steps,
         "Consider replacing the ssh keys in\n" .
         "    $Config{GLOBUS_LOCATION}/etc/ssh\n" .
         "with symbolic links to the system ssh keys in /etc or /etc/ssh\n";
}

########################################
# Build and install MPICH-G2 if specified
########################################
if (defined $Config{MPICH_G2}) {
    my $ref = $Config{MPICH_G2};
    my $filename = $ref->{filename};
    my $install_dir = $ref->{install};
    my $flavor = $ref->{flavor};
    my $arch = undef;
    $arch = $ref->{arch} if defined $ref->{arch};

    if ($install_dir !~ /^\//) {
        $install_dir = "$Config{GLOBUS_LOCATION}/$install_dir";
    }

    opendir DIR, '.' or die ".: $!\n";
    my @files_before = readdir DIR;
    closedir DIR;
    my %already_existed = map { $_ => 1 } @files_before;

    Execute @As_Installer, '/bin/sh', '-c',
            "$gzip -d < $ref->{filename} | $tar xf -";

    opendir DIR, '.' or die ".: $!\n";
    my @files_after = readdir DIR;
    closedir DIR;

    my @new_files = ();
    foreach my $file (@files_after) {
        push @new_files, $file if not $already_existed{$file};
    }

    if (scalar @new_files == 0) {
        die "Can't determine MPICH source directory, " .
            "tar didn't create anything\n";
    }
    elsif (scalar @new_files == 1) {
        my $src_dir = $new_files[0];
        print "% cd $working_dir/$src_dir\n";
        chdir "$working_dir/$src_dir" or die "$working_dir/$src_dir: $!\n";
    }
    else {
        die "Can't determine MPICH source directory, tar created (@new_files)\n";
    }

    my @configure_args = ( "-device=globus2:-flavor=$ref->{flavor}" );
    if (defined $ref->{arch}) {
        push @configure_args, "-arch=$ref->{arch}";
    }
    push @configure_args, "-prefix=$install_dir";
    Execute @As_Installer, './configure', @configure_args;
    Execute @As_Installer, 'make';
    Execute @As_Installer, 'make', 'install';


}

########################################
# Final checking and setup
########################################
if (-d "$Config{GLOBUS_LOCATION}/var/condor") {
    #
    # We installed Condor-G.
    #
    push @manual_steps,
         "Check the ownership of $Config{GLOBUS_LOCATION}/var/condor\n" .
         "It should probably be owned by user \"condor\"\n";
}

chdir '/tmp';
if ($Cleanup) {
    Execute @As_Myself, 'rm', '-rf', $working_dir;
}

########################################################################
# Some things can't be easily automated, some things shouldn't be
# automated, and some things I just haven't gotten around to automating
# yet.  Tell the user what still needs to be done manually.  All these
# things are collected and printed in one well-marked block at the end
# of the output (which should be saved to a log).
########################################################################
my $text = Manual_Steps_Text @manual_steps;
print $text;
open INFO, ">>$info_file";
print INFO $text;
close INFO;

########################################################################
############################## Subroutines #############################
########################################################################

#
# Extract the actual revision number from an RCS or CVS revision string.
# The code is a little convoluted to prevent RCS or CVS from stepping
# on the search pattern.
#
sub Strip_Revision_String($) {
    my($revision) = @_;
    my $rev_tag = '\$' . 'Revision:';
    if ($revision =~ /^$rev_tag ([\d.]+) \$$/) {
        return $1;
    }
    else {
        return $revision;
    }
} # Strip_Revision_String

# ----------------------------------------------------------------------

#
# Called by Get_Config.
# Return an error message for a given filename.
# Return undef if there's no problem.
#
sub File_Error(@) {
    my $varname = undef;
    my $executable = undef;
    my $name = undef;

    foreach my $arg (@_) {
        if ($arg =~ /^-varname=(.*)$/) {
            $varname = $1;
        }
        elsif ($arg eq '-executable') {
            $executable = 1;
        }
        elsif ($arg =~ /^-/) {
            die "Internal error, File_Error, arg \"$arg\"\n";
        }
        else {
            $name = $arg;
        }
    }

    if ($name !~ /^\//) {
        return "$varname file \"$name\", relative path not allowed\n";
    }
    elsif (not -e $name) {
        return "$varname file \"$name\" does not exist\n";
    }
    elsif (not -f _) {
        return "$varname file \"$name\" is not an ordinary file\n";
    }
    elsif (not $executable and not -r _) {
        return "Can't read $varname file \"$name\"\n";
    }
    elsif (-z _) {
        return "$varname file \"$name\" is empty\n";
    }
    elsif ($executable and not -x _) {
        return "$varname file \"$name\" is not executable\n";
    }
    else {
        return undef;
    }
} # File_Error

# ----------------------------------------------------------------------

#
# Given a string of the form "~foo", returns user foo's home directory.
# If there is no such user, returns the unmodified string (which will
# probably cause an error later).
#
sub Expand_Tilde($) {
    my($arg) = @_;
    my $username = $arg;
    $username =~ s/^~//;
    my @pw = getpwnam $username;
    if (@pw) {
        return $pw[7];
    }
    else {
        return $arg;
    }
} # Expand_Tilde

# ----------------------------------------------------------------------

#
# Returns the next line from the file.
# A trailing '\', possibly followed by whitespace, indicates a line
# continuation.
# Comments (introduced by '#') are stripped.
# Leading and trailing whitespace are stripped.
#
# The '\' may be followed by whitespace, but not by a comment.
# Any '#' character introduces a comment; there is no provision for
# escaping a '#' character.
# 
sub Next_Line($) {
    my($file) = @_;

    my $result;
    {
        no strict 'refs';
        $result = <$file>;
    }
    return $result if not defined $result; # end of file

    while ($result =~ /\\\s*$/) {
        chomp $result;
        $result =~ s/\\\s*$//;
        my $contin = <$file>;
        if (defined $contin) {
            $result .= $contin;
        }
        else {
            die "Last line ends with '\\'\n";
        }
    }
    $result =~ s/#.*$//;
    $result =~ s/^\s+//;
    $result =~ s/\s+$//;
    return $result;
} # Next_Line;

# ----------------------------------------------------------------------

#
# Read and parse the config file (name given on the command line) and
# return the results as a hash (to be assigned to the global %Config).
#
sub Get_Config($) {
    my($config_file) = @_;
    my @errors = ();
    my $default_prefix = undef;

    #
    # %Var_Info is a hash of hash references.
    # Each element is basically a declaration for a configuration variable.
    # This information is used for validity checking, and is local
    # to Get_Config.
    #
    my %Var_Info = (
        CONFIG_FILE_REVISION =>
            { type => 'string', required => 0 },
        TEMP_DIR =>
            { type => 'existing_directory', required => 0, default => '/tmp' },
        TAR =>
            { type => 'executable_file', required => 0 },
        GZIP =>
            { type => 'executable_file', required => 0 },
        PATH =>
            { type => 'path', required => 1 },
        ENV =>
            { type => 'array_of_string', required => 0 },
        INSTALLER_USER =>
            { type => 'user_name', required => 0, default => $Default_User },
        INSTALLER_GROUP =>
            { type => 'group_name', required => 0, default => $Default_Group },
        USE_SDSC_SU =>
            { type => 'boolean', required => 0, default => 0 },
        UMASK =>
            { type => 'umask', required => 0, default => '022' },
        GPT_TARBALL =>
            { type => 'file', required => 1 },
        BUNDLE =>
            { type => 'array_of_bundle', required => 1 },
        UPDATE =>
            { type => 'array_of_bundle', required => 0 },
        PRE_POSTINSTALL =>
            { type => 'string', required => 0 },
        GPT_LOCATION =>
            { type => 'new_directory', required => 0 },
        GLOBUS_LOCATION =>
            { type => 'new_directory', required => 1 },
        GLOBUS_LOCAL_DIRECTORY =>
            { type => 'new_directory', required => 0 },
        GLOBUS_HOSTNAME =>
            { type => 'string', required => 0 },
        GRID_MAPFILE =>
            { type => 'file', required => 0 },
        HOST_CERT =>
            { type => 'file', required => 0 },
        HOST_KEY =>
            { type => 'file', required => 0 },
        LDAP_CERT =>
            { type => 'file', required => 0 },
        LDAP_KEY =>
            { type => 'file', required => 0 },
        BATCH_SYSTEM =>
            { type => 'batch_system', required => 0 },
        JOB_MANAGER =>
            { type => 'job_manager', required => 0 },
        'MPICH-G2' =>
            { type => 'mpich-g2', required => 0 },
        CA_CERT_TARBALL =>
            { type => 'file', required => 0 }
    );

    print "Getting configuration from $config_file\n";

    #
    # Read config variables from config file.
    # Check for duplicate entries, unrecognized names, and syntax errors.
    #
    open CONFIG, $config_file or die "$config_file: $!\n";
    while (defined ($_ = Next_Line 'CONFIG')) {
        next if /^$/;
        if (/^(\.?[\w-]+)\s+(.*)$/) {
            my ($name, $value) = ($1, $2);
            #
            # Expand ~username at the beginning of the string.
            # Assume a username consists of one or more word
            # characters or hyphens.
            #
            $value =~ s/^~[\w-]+/Expand_Tilde $&/e;

            #
            # .PREFIX is not a true configuration option.  Instead, it
            # allows a default directory prefix to be set for options
            # that specify file names.  The default prefix, if any, is
            # prepended, with a '/' character, to any following file or
            # directory specifications.  It does not apply to options
            # given as absolute file names (starting with '/' or '~').
            #
            # This is in effect a limited macro facility, intended
            # to avoid extremely long lines in configuration files.
            # No checking is done on the prefix; the only checking is
            # on actual options after they're expanded.
            #
            # This expansion is performed only for options of type 'file',
            # 'array_of_bundle', and 'mpich_g2'.
            # 
            if ($name eq '.PREFIX') {
                $default_prefix = $value;
            }

            elsif (defined $Var_Info{$name}) {
                my $Var = $Var_Info{$name};

                if ($Var->{type} eq 'file' or
                    $Var->{type} eq 'array_of_bundle' or
                    $Var->{type} eq 'mpich_g2')
                {
                    #
                    # URLs are no longer supported
                    #
                    if ($value =~ m<^(ftp|http)://>) {
                        push @errors, "URLs are no longer supported, line $.\n";
                    }
                    #
                    # Prepend the default prefix (if any) only if the
                    # value is a relative pathname.
                    #
                    elsif ($value !~ m<^/> and defined $default_prefix) {
                        $value = "$default_prefix/$value";
                    }

                    #
                    # Bundles and updates may have additional attributes
                    # specified on the same line.  Recognized attributes
                    # are:
                    #     kind=binary
                    #     kind=source
                    #     kind=rpm
                    #     flavor=<string>
                    #     option=<string>
                    # Multiple flavors may be specified, separated by
                    # commas, e.g.:
                    #     flavor=gcc32dbg,gcc32
                    # Options are passed to gpt-install or gpt-build.
                    # Multiple options may be specified, separated by
                    # commas, e.g.:
                    #     -update,-std-flavors
                    #
                    if ($Var->{type} eq 'array_of_bundle' or
                        $Var->{type} eq 'mpich_g2')
                    {
                        my $filename = undef; # array_of_bundle and mpich_g2
                        my $kind     = undef; # array_of_bundle only
                        my $flavor   = undef; # array_of_bundle and mpich_g2
                        my $option   = undef; # array_of_bundle only
                        my $install  = undef; # mpich_g2 only
                        my $arch     = undef; # mpich_g2 only

                        foreach my $field (split /\s+/, $value) {
                            if (lc $field =~ /^kind=(.*)$/) {
                                if (defined $kind) {
                                    push @errors, "Duplicate kind, line $.\n";
                                }
                                else {
                                    if ($1 eq 'binary' or
                                        $1 eq 'source' or
                                        $1 eq 'rpm')
                                    {
                                        $kind = $1;
                                    }
                                    else {
                                        push @errors,
                                             "Unrecognized kind, line $., " .
                                             "should be \"binary\", " .
                                             "\"source\", or \"rpm\"\n";
                                    }
                                }
                            }
                            elsif (lc $field =~ /^flavor=(.*)$/) {
                                if (defined $flavor) {
                                    push @errors,
                                         "Duplicate flavor, line $." .
                                         " (use \"flavor=$flavor,$1\")\n";
                                }
                                else {
                                    $flavor = $1;
                                }
                            }
                            elsif (lc $field =~ /^option=(.*)$/) {
                                if (defined $option) {
                                    push @errors,
                                         "Duplicate option, line $." .
                                         " (use \"option=$option,$1\")\n";
                                }
                                else {
                                    $option = $1;
                                }
                            }
                            elsif (lc $field =~ /^install=(.*)$/) {
                                if (defined $install) {
                                    push @errors,
                                         "Duplicate install attr, line $.\n";
                                }
                                else {
                                    $install = $1;
                                }
                            }
                            elsif (lc $field =~ /^arch=(.*)$/) {
                                if (defined $arch) {
                                    push @errors,
                                         "Duplicate arch, line $.\n";
                                }
                                else {
                                    $option = $1;
                                }
                            }
                            elsif ($field =~ /^(\w+)=/) {
                                push @errors,
                                     "Unrecognized attribute \"$1\", line $.\n";
                            }
                            else {
                                if (defined $filename) {
                                    push @errors,
                                         "Duplicate name, line $." .
                                         " (possible space in filename?)\n";
                                }
                                else {
                                    $filename = $field;
                                }
                            }
                        }
                        #
                        # Check for errors in attributes.
                        #
                        if ($Var->{type} eq 'array_of_bundle') {
                            if (defined $install) {
                                push @errors, "install attribute may not be " .
                                              "defined for bundles\n";
                            }
                            if (defined $arch) {
                                push @errors, "arch attribute may not be " .
                                              "defined for bundles\n";
                            }
                        }
                        elsif ($Var->{type} eq 'mpich-g2') {
                            if (defined $kind) {
                                push @errors, "kind attribute may not be " .
                                              "defined for MPICH-G2\n";
                            }
                            if (defined $option) {
                                push @errors, "option attribute may not be " .
                                              "defined for MPICH-G2\n";
                            }
                            if (not defined $filename) {
                                push @errors, "Missing filename for MPICH-G2\n";
                            }
                            if (defined $flavor) {
                                if ($flavor =~ /,/) {
                                    push @errors,
                                         "Only one flavor may be specified " .
                                         "for MPICH-G2\n";
                                }
                            }
                            else {
                                push @errors, "Missing flavor for MPICH-G2\n";
                            }
                            if (defined $install) {
                                if ($install =~ /^\//) {
                                    # ok, absolute path
                                }
                                elsif ($install =~ /\//) {
                                    # A relative path is ok, but
                                    # the depth cannot exceed 1 (no
                                    # recursive mkdir).
                                    push @errors,
                                         "Relative path for MPICH-G2 " .
                                         "can be at most one level deep\n";
                                }
                            }
                            else {
                                push @errors,
                                     "Missing install attr for MPICH-G2\n";
                            }
                        }
                        else {
                            die "Internal error, type = $Var->{type}";
                        }
                        $value = {};
                        $value->{filename}  = $filename;
                        $value->{kind}      = $kind    if defined $kind;
                        $value->{option}    = $option  if defined $option;
                        $value->{flavor}    = $flavor  if defined $flavor;
                        $value->{install}   = $install if defined $install;
                        $value->{arch}      = $arch    if defined $arch;
                        $value->{is_update} = 1 if $name eq 'UPDATE';
                    }
                }

                if ($Var->{type} =~ /^array_of/) {
                    push @{$Var->{value}}, $value;
                }
                else {
                    if (defined $Var->{value}) {
                        push @errors,
                             "Duplicate entry for \"$name\" at line $.\n";
                    }
                    else {
                        $Var->{value} = $value;
                    }
                }
            }

            else {
                push @errors, "Unrecognized option \"$name\" at line $.\n"
            }
        }
        else {
            push @errors, "Syntax error at line $.\n";
        }
    }
    close CONFIG;

    #
    # Validate each variable, depending on its type.
    #
    VAR:
    foreach my $varname (sort keys %Var_Info) {
        my $var = $Var_Info{$varname};
        if (not defined $var->{value}) {
            if ($var->{required}) {
                push @errors, "Missing option $varname\n";
                next VAR;
            }
            elsif (defined $var->{default}) {
                $var->{value} = $var->{default};
            }
            else {
                $var->{value} = undef;
                next VAR;
            }
        }

        #
        # An arbitrary string.
        #
        if ($var->{type} eq 'string') {
            #
            # Nothing to validate
            #
        }

        #
        # An array of arbitrary strings.
        #
        elsif ($var->{type} eq 'array_of_string') {
            #
            # Nothing to validate
            #
        }

        #
        # An existing directory.
        # It must be readable, writable, and searchable.
        #
        elsif ($var->{type} eq 'existing_directory') {
            my $dir = $var->{value};
            if ($dir !~ /^\//) {
                push @errors, "$varname directory \"$dir\", " .
                              "relative path not allowed\n";
            }
            if (not (-d $dir and -r _ and -w _ and -x _)) {
                push @errors, "Bad $varname directory \"$dir\"\n";
            }
        }

        #
        # A directory to be created.
        # If it already exists, it must be empty, readable, writable,
        # and searchable.
        #
        elsif ($var->{type} eq 'new_directory') {
            my $dir = $var->{value};
            if ( $AIX_Kludge and
                 ( ( $varname eq 'GPT_LOCATION' ) or
                   ( $varname eq 'GLOBUS_LOCATION' and 
                     ( $Var_Info{GPT_LOCATION}->{value} eq
                       $Var_Info{GLOBUS_LOCATION}->{value} ) ) ) )
            {
                # Ok for directory to exist.
            }
            else {
                if (not -e $dir) {
                    # ok
                }
                elsif (-d $dir) {
                    if (Is_Empty_Dir $dir) {
                        if (not (-r $dir and -w _ and -x _)) {
                            push @errors,
                                 "Bad $varname directory \"$dir\"\n";
                        }
                    }
                    else {
                        push @errors, "$varname \"$dir\" is not empty\n";
                    }
                }
                else {
                    push @errors, "$varname \"$dir\" is not a directory\n";
                }
            }
        }

        #
        # A path, consisting of a colon-delimited list of directories.
        # Each directory must exist, and must be readable and searchable.
        #
        elsif ($var->{type} eq 'path') {
            foreach my $dir (split /:/, $var->{value}) {
                if ($dir !~ /^\//) {
                    push @errors,
                         "Bad directory in ${varname}: \"$dir\"\n";
                }
                elsif (not -d $dir) {
                    push @errors,
                         "Nonexistent directory in ${varname}: \"$dir\"\n";
                }
                elsif (not -r $dir or not -x $dir) {
                    push @errors,
                         "Bad permissions on directory in " .
                         "${varname}: \"$dir\"\n";
                }
            }
        }

        #
        # A Unix user name.
        #
        elsif ($var->{type} eq 'user_name') {
            my @pw = getpwnam $var->{value};
            if (not defined $pw[2]) {
                push @errors, "Bad $varname \"$var->{value}\", no such user\n";
            }
            if (not $Running_As_Root and $var->{value} ne $This_User) {
                push @errors, "Bad $varname \"$var->{value}\", " .
                              "permission denied\n" .
                              "Run $Program_Name as root or " .
                              "don't specify $varname\n";
            }
        }

        #
        # A Unix group name.
        #
        elsif ($var->{type} eq 'group_name') {
            my @gr = getgrnam $var->{value};
            if (not defined $gr[2]) {
                push @errors, "Bad $varname \"$var->{value}\", no such group\n";
            }
            if (not $Running_As_Root and $var->{value} ne $This_Group) {
                push @errors, "Bad $varname \"$var->{value}\", " .
                              "permission denied\n" .
                              "Run $Program_Name as root or " .
                              "don't specify $varname\n";
            }
        }

        #
        # A umask, a sequence of one or more octal digits.
        #
        elsif ($var->{type} eq 'umask') {
            if ($var->{value} !~ /^[0-7]+$/) {
                push @errors, "Bad $varname \"$var->{value}\"\n";
            }
        }

        #
        # A Boolean value.
        # False may be represented as '0', 'no', or 'false'.
        # True may be represented as '1', 'yes', or 'true'.
        # Value is case-insensitive.
        #
        elsif ($var->{type} eq 'boolean') {
            if ($var->{value} eq '0' or
                lc $var->{value} eq 'no' or
                lc $var->{value} eq 'false')
            {
                $var->{value} = 0;
            }
            elsif ($var->{value} eq '1' or
                lc $var->{value} eq 'yes' or
                lc $var->{value} eq 'true')
            {
                $var->{value} = 1;
            }
            else {
                push @errors, "$varname must be one of the following:\n" .
                              "    0, no, false, 1, yes, true\n";
            }
        }

        elsif ($var->{type} eq 'array_of_bundle') {
            foreach my $item (@{$var->{value}}) {
                my $error = File_Error "-varname=$varname", $item->{filename};
                push @errors, $error if defined $error;
                if (defined $item->{kind} and $item->{kind} eq 'rpm') {
                    push @errors,
                         "RPM bundles cannot be installed " .
                         "by a non-root user\n";
                }
            }
        }

        elsif ($var->{type} eq 'file') {
            my $error = File_Error "-varname=$varname", $var->{value};
            push @errors, $error if defined $error;
        }

        elsif ($var->{type} eq 'executable_file') {
            my $error = File_Error
                            "-varname=$varname", "-executable", $var->{value};
            push @errors, $error if defined $error;
        }

        elsif ($var->{type} eq 'batch_system') {
            $var->{value} = lc $var->{value};

            my @batch_systems = qw( condor easymcs fork glunix grd
                                    loadleveler lsf nqe nswc pbs pexec
                                    prun );
            my %is_batch_system = map { ( $_ => 1 ) } @batch_systems;
            if (not $is_batch_system{$var->{value}}) {
                push @errors, "$varname must be one of:\n" .
                              "    @batch_systems\n";
            }

        }

        elsif ($var->{type} eq 'job_manager') {
            #
            # For now, treat all the arguments as a single string.
            # We'll split it into words when we use it; the first word
            # is the name of the jobmanager (e.g., "pbs"), any remaining
            # words are arguments to the setup script.
            #
            # Later, we'll do more checking.
            #
        }

        elsif ($var->{type} eq 'mpich-g2') {
            #
            # For now, treat all the arguments as a single string.
            # We'll split it into words when we use it; the first word
            # is the name of the mpich tarball, other arguments specify
            # attributes.
            #
            # Later, we'll do more checking here.
            #
        }

        else {
            #
            # The missing "\n" in the error message is deliberate.
            # It causes Perl to print more information about the location
            # of the error.
            #
            die "Internal error, bad variable type \"$var->{type}\"";
        }

    }

    #
    # If GPT_LOCATION is not specified, set it to the same directory
    # as GLOBUS_LOCATION (which has already been validated above).
    #
    if (not defined $Var_Info{GPT_LOCATION}->{value}) {
        $Var_Info{GPT_LOCATION}->{value} = $Var_Info{GLOBUS_LOCATION}->{value};
    }

    if (defined $Var_Info{CONFIG_FILE_REVISION}->{value}) {
        $Var_Info{CONFIG_FILE_REVISION}->{value} =
            Strip_Revision_String $Var_Info{CONFIG_FILE_REVISION}->{value};
    }

    #
    # Special check: GLOBUS_LOCAL_DIRECTORY may not be a subdirectory
    # of GLOBUS_LOCATION.
    #
    if (defined $Var_Info{GLOBUS_LOCAL_DIRECTORY}->{value}) {
        my $globus_dir = $Var_Info{GLOBUS_LOCATION}->{value};
        my $var_dir = $Var_Info{GLOBUS_LOCAL_DIRECTORY}->{value};
        if ($var_dir =~ /^\Q$globus_dir\E\//) {
            push @errors, "GLOBUS_LOCAL_DIRECTORY may not be a " .
                          "subdirectory of GLOBUS_LOCATION\n" .
                          "If you don't need a separate local directory, " .
                          "don't specify GLOBUS_LOCAL_DIRECTORY.\n";
        }
    }

    if (@errors) {
        my $Error_s = (scalar @errors == 1 ? 'Error' : 'Errors');
        die ">>> $Error_s in config file ${config_file}:\n",
            @errors;
    }

    my %Result = ();

    foreach my $varname (keys %Var_Info) {
        $Result{$varname} = $Var_Info{$varname}->{value};
    }

    foreach my $key (sort keys %Result) {
        my $value = $Result{$key};
        if (ref $value eq 'ARRAY') {
            printf "    %-20s => {\n", $key;
            foreach my $elem (@$value) {
                if ($key eq 'BUNDLE' or $key eq 'UPDATE') {
                    my @fields = ("\"$elem->{filename}\"");
                    if (defined $elem->{kind}) {
                        push @fields, "kind=$elem->{kind}";
                    }
                    if (defined $elem->{option}) {
                        push @fields, "option=$elem->{option}";
                    }
                    if (defined $elem->{flavor}) {
                        push @fields, "flavor=$elem->{flavor}";
                    }
                    print "        @fields\n";
                }
                else {
                    print "        \"$elem\"\n";
                }
            }
            print "    }\n";
        }
        elsif (ref $value eq 'HASH') {
            printf "    %-20s => {\n", $key;
            foreach my $subkey (sort keys %$value) {
                printf "        %-8s => %s\n", $subkey, $value->{$subkey};
            }
            print "    }\n";
        }
        else {
            printf "    %-20s => %s",
                   $key,
                   defined $value ? "\"$value\"" : 'undef';
            #
            # Currently, attributes can only be defined for BUNDLE,
            # which is an array.
            #
            print "\n";
        }
    }

    return %Result;
} # Get_Config

# ----------------------------------------------------------------------

#
# Collect system information and return it in a hash.
#
sub Get_System_Information() {
    my %Result = ();

    chomp($Result{OSNAME}  = `uname -s`);
    chomp($Result{MACHINE} = `uname -m`);
    $Result{LC_OSNAME}  = lc $Result{OSNAME};
    $Result{LC_MACHINE} = lc $Result{MACHINE};

    if ($Result{LC_MACHINE} eq 'ia64') {
        $Result{BITS} = 64;
    }
    else {
        $Result{BITS} = 32;
    }

    #
    # Detect whether we're running inetd or xinetd, and what its PID is.
    #
    my $ps_command;

    if ($Result{LC_OSNAME} eq 'darwin' or $Result{LC_OSNAME} =~ /bsd/) {
        $ps_command = 'ps -u -U root';
    }
    else {
        $ps_command = 'ps -f -u root';
    }

    my @inetd_processes = ();
    my @xinetd_processes = ();

    open PIPE, "$ps_command |";
    while (<PIPE>) {
        chomp;
        s/^\s*//;
        my @fields = split;
        my $pid = $fields[1];
        if (/\binetd\b/) {
            push @inetd_processes, $pid;
        }
        elsif (/\bxinetd\b/) {
            push @xinetd_processes, $pid;
        }
    }
    close PIPE;

    if (scalar @inetd_processes == 1 and scalar @xinetd_processes == 0) {
        $Result{NET_DAEMON} = 'inetd';
        $Result{NET_DAEMON_PID} = $inetd_processes[0];
    }
    elsif (scalar @inetd_processes == 0 and scalar @xinetd_processes == 1) {
        $Result{NET_DAEMON} = 'xinetd';
        $Result{NET_DAEMON_PID} = $xinetd_processes[0];
    }
    elsif (-x '/usr/sbin/inetd' and not -x '/usr/sbin/xinetd') {
        $Result{NET_DAEMON} = 'inetd';
    }
    elsif (-x '/usr/sbin/xinetd' and not -x '/usr/sbin/inetd') {
        $Result{NET_DAEMON} = 'xinetd';
    }

    if (defined $Result{NET_DAEMON} and $Result{NET_DAEMON} eq 'inetd') {
        foreach my $command ( '/etc/init.d/inet',
                              '/etc/init.d/inetd',
                              '/etc/rc.d/init.d/inet',
                              '/etc/rc.d/init.d/inetd' )
        {
            if (-x $command) {
                $Result{NET_DAEMON_RELOAD} = "$command reload";
                last;
            }
        }
        if (not defined $Result{NET_DAEMON_RELOAD}) {
            if (defined $Result{NET_DAEMON_PID}) {
                $Result{NET_DAEMON_RELOAD}
                    = "kill -HUP $Result{NET_DAEMON_PID}";
            }
            else {
                $Result{NET_DAEMON_RELOAD}
                    = "kill -HUP <inetd process>";
            }
        }
    }
    elsif (defined $Result{NET_DAEMON} and $Result{NET_DAEMON} eq 'xinetd') {
        if (-x '/etc/init.d/xinetd') {
            $Result{NET_DAEMON_RELOAD} = '/etc/init.d/xinetd reload';
        }
        elsif (-x '/etc/rc.d/init.d/xinetd') {
            $Result{NET_DAEMON_RELOAD} = '/etc/rc.d/init.d/xinetd reload';
        }
    }

    print "System Information:\n";
    foreach my $key (sort keys %Result) {
        my $value = $Result{$key};
        if (ref $value eq 'ARRAY') {
            printf "    %-20s => {\n", $key;
            foreach my $elem (@$value) {
                print "        \"$elem\"\n";
            }
            print "    }\n";
        }
        else {
            printf "    %-20s => \"%s\"\n", $key, $Result{$key};
        }
    }

    return %Result;
} # Get_System_Information

# ----------------------------------------------------------------------

#
# Given a number of seconds (possibly fractional), return a readable
# string, similar to the format used by the csh "time" builtin command.
#
sub Elapsed_Time_Image($) {
    my($seconds) = @_;

    my $h = int($seconds / 3600);
    $seconds -= 3600 * $h;      # Can't use "%"; it truncates.

    my $m = int($seconds / 60);
    $seconds -= 60 * $m;

    if ($h > 0) {
        return sprintf '%d:%02d:%05.2f', $h, $m, $seconds;
    }
    else {
        return sprintf '%d:%05.2f', $m, $seconds;
    }
} # Elapsed_Time_Image

# ----------------------------------------------------------------------

#
# Given a raw timestamp, return a human-readable string.
# Time zone is UTC, format is basically ISO-8601.
#
sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime time;
    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
} # Time_Image

# ----------------------------------------------------------------------

#
# Create a unique temporary file and return its name.
#
sub Make_Temp_File($) {
    my($content) = @_;
    my $filename = sprintf "$working_dir/input-%03d",
                           $temp_file_serial_number ++;
    open TMP, ">$filename" or die "${filename}: $!\n";
    print TMP $content;
    close TMP;
    return $filename;
} # Make_Temp_File

# ----------------------------------------------------------------------

#
# Given a numeric value returned by system(), interpret it
# and return the result as a hash reference.
# Die if result indicates failure and second argument (check) is true.
# Print a message on failure if check is false.
#
# Note: die'ing and/or printing a message from this routine is a bit ugly,
# but it's useful in the context of this program (gpt-wizard).
#
sub Get_Result($$) {
    my ($status, $check) = @_;
    my $Result = {};
    my $hi_8 = ($status & 0xff00) >> 8;
    my $lo_8 =  $status & 0x00ff;

    my $WSTOPFLG = 0x007f;
    my $WCOREFLG = 0x0080;

    if ($lo_8 == $WSTOPFLG) {
        #
        # Stopped by signal
        #
        $Result->{signal} = $hi_8;
        $Result->{stopped} = 1;
        $Result->{desc} = "stopped, signal $hi_8";
        if ($check) {
            die "$Result->{desc}\n";
        }
        else {
            print "[$Result->{desc}]\n";
        }
    }
    elsif ($lo_8 == 0) {
        #
        # Normal exit() (possibly with non-zero status)
        #
        $Result->{status} = $hi_8;
        $Result->{desc} = "exit $hi_8";
        if ($Result->{status} != 0) {
            if ($check) {
                die "$Result->{desc}\n";
            }
            else {
                print "[$Result->{desc}]\n";
            }
        }
    }
    elsif ($hi_8 == 0) {
        #
        # Killed by signal
        #
        my $signal = $lo_8;
        if ($signal & $WCOREFLG) {
            $signal &= ~$WCOREFLG;
            $Result->{core} = 1;
        }
        $Result->{signal} = $signal;
        $Result->{desc} = "signal $signal";
        if ($Result->{core}) {
            $Result->{desc} .= " (core dumped)";
        }
        if ($check) {
            die "$Result->{desc}\n"
        }
        else {
            print "[$Result->{desc}]\n";
        }
    }
    return $Result;
} # Get_Result

# ----------------------------------------------------------------------

sub Get_Update_Flavors($) {
    my($filename) = @_;

    my $module_name = File::Basename::basename $filename;
    #
    # File name format is name-version.tar.gz
    #
    $module_name =~ s/-[^-]*\.tar\.gz$//;

    my %flavor = ();

    open PIPE, "$ENV{GLOBUS_LOCATION}/sbin/gpt-query $module_name |";
    while (<PIPE>) {
        chomp;
        #
        # The gpt-query output format changed around gpt release 3.0.
        #

        next if not /ver:/ and not /pkg version:/;
        #
        # Strip leading whitespace and grab first word.
        #
        s/^\s*//;
        s/\s.*$//;
        #
        # e.g., "globus_openssl_module-gcc32dbg-dev".
        # Split on /-/ and grab next-to-last field.
        #
        my @fields = split /-/, $_;
        if (scalar @fields >= 2) {
            my $new_flavor = $fields[$#fields - 1];
            $flavor{$new_flavor} = 1;
        }
    }
    close PIPE;

    my @flavors = sort keys %flavor;
    if (@flavors) {
        return grep { $_ ne 'noflavor' } @flavors;
    }
    else {
        die "Unable to determine flavors for $filename\n";
    }
} # Get_Update_Flavors

# ----------------------------------------------------------------------

#
# Execute a command with arguments.
# The command name is preceded by zero or more options starting with '-'.
#
# -verbose      Print command to stdout before executing.
# -time         Like csh "time" command
# -time=N       Show time only if command took at least N wall seconds
# -background   Run command in background; don't wait for completion.
# -check        Die if command fails.
# -user=name    Execute as specified user (and group).
#               Name can be "user", "user.group", or "user:group".
# -stdin=file   Redirect stdin from specified file.
# -input=string Redirect stdin from temp file with specified contents.
# -error=string Die immediately with an error message.
# 
sub Execute(@) {
    my @args = @_;
    my $Verbose = 0;
    my $Min_Time = undef;
    my $Background = 0;
    my $Check = 0;
    my $User = undef;
    my $Group = undef;
    my $Input_String = undef;
    my $Stdin = undef;
    my $Stdin_Is_Temporary = undef;
    my @before;
    my @after;
    my $system_result;

    Debug "Execute, scalar \@args = ", scalar @args, "\n";
    my @caller = caller;
    Debug "   Called from $caller[0]::$caller[1] line $caller[2]\n";
    #
    # Process arguments
    #
    while ( scalar @args > 0 && $args[0] =~ /^-/) {
        my $arg = shift @args;
        if ($arg eq '-verbose') {
            $Verbose = 1;
        }
        elsif ($arg eq '-time') {
            $Min_Time = 0;
        }
        elsif ($arg =~ /^-time=(\d+)$/) {
            $Min_Time = $1;
        }
        elsif ($arg eq '-background') {
            $Background = 1;
        }
        elsif ($arg eq '-check') {
            $Check = 1;
        }
        elsif ($arg =~ /^-user=(.+)$/) {
            $User = $1;
            if ($User =~ /^(.*)[.:](.*)$/) {
                $User = $1;
                $Group = $2;
            }
        }
        elsif ($arg =~ /^-stdin=(.+)$/) {
            $Stdin = $1;
        }
        elsif ($arg =~ /^-input=(.+)$/s) {
            #
            # Need to use "/s" modifier so "." matches "\n"
            #
            $Input_String = $1;
            $Stdin = Make_Temp_File $Input_String;
            $Stdin_Is_Temporary = 1;
        }
        elsif ($arg =~ /^-error=(.+)$/) {
            die $1;
        }
        else {
            die "Execute: Unrecognized argument: $arg\n";
        }
    }

    Debug "   args = @args\n";
    if (defined $User and not $Config{USE_SDSC_SU}) {
        my @pw = getpwnam $User;
        die "${User}: No such user\n" if not @pw;
        my @gr;
        if (defined $Group) {
            @gr = getgrnam $Group;
            die "${Group}: No such group\n" if not @gr;
        }
        my $uid = $pw[2];
        my $gid = defined $Group ? $gr[2] : $pw[3];
        my $pid;
        if (($pid = fork) == 0) {
            #
            # This is the child process.
            # Set the real and effective user (and group) id,
            # and continue to handle the call.
            #
            # To be honest, I don't quite understand the distinction
            # between "real" and "effective" user and group ids, so I
            # set both just to be sure.
            #
            # It may be possible to temporarily set the effective(?) user
            # and group ids, run the command, and set them back, without
            # forking a child process, but it doesn't seem to be possible
            # to do this in a portable and reliable manner.
            #
            # Set the group ids first; once we set the user ids, we're no
            # longer root and don't have permission to set the group ids.
            #
            # Setting $< and $( (setruid() and setrgid()) is not supported
            # on AIX; use eval to avoid blowing up on the attempt.
            #
            # Setting $) or $> silently does nothing if we don't have
            # permission.  Confirm the setting afterward, and die if
            # it failed.
            #
            if (defined $gid) {
                eval { $( = $gid };
                $) = $gid;
                my $new_group = $);
                $new_group =~ s/ .*//;
                die "Setting effective gid failed\n" if $new_group ne $gid;
            }
            eval { $< = $uid };
            $> = $uid;
            die "Setting effective uid failed\n" if $> ne $uid;
            Debug "Child: \$< = $< \$> = $>\n";
            delete $SIG{__DIE__};
        }
        else {
            #
            # This is the parent process.
            # Wait for the child to finish.  
            #
            $Running{$pid} = 1;
            Debug "Parent calling waitpid\n";
            if (waitpid $pid, 0 == -1) {
                Debug ">>> waitpid returned -1, \$? = $?, \$! = $!\n",
                      "    Ignoring error (ick)\n";
                # die "waitpid ${pid}: $! (\$? = $?)\n";
            }
            Debug "Parent after waitpid, \$? = $?\n";
            delete $Running{$pid};
            return Get_Result $?, $Check;
        }
    }

    if (defined $Min_Time) {
        print Time_Image time, "\n";
    }

    if ($Verbose) {
        Debug "Building command_string, args = @args\n";
        my $command_string = '% ';
        $command_string .= "[$User] " if defined $User;
        $command_string .= "@args";
        $command_string .= " < $Stdin" if defined $Stdin;
        $command_string .= " &" if $Background;
        print "$command_string\n";
        if (defined $Input_String) {
            print "  (input is ", Image $Input_String, ")\n";
        }
    }

    if ($Background) {
        my $pid = fork;
        if ($pid != 0) {
            #
            # I'm the parent
            #
            my $Result = {};
            $Result->{pid} = $pid;
            return $Result;
        }
    }

    if (defined $Stdin) {
        open SAVE_STDIN, "<&STDIN";
        print SAVE_STDIN if 0;          # keep "perl -w" happy
        close STDIN;
        open STDIN, "<$Stdin" or die "${Stdin}: $!\n";
    }
    if (defined $Min_Time) {
        @before = POSIX::times;
    }
    if (defined $User and $Config{USE_SDSC_SU}) {
        #
        # Note: This ignores INSTALLER_GROUP
        #
        my @arguments = @args;
        foreach (@arguments) {
            $_ = "'$_'" if / /;
        }
        $system_result = system 'su', $User, '-c',
                         "umask $Config{UMASK} ; @arguments";
    }
    else {
        $system_result = system @args;
    }
    Debug "system_result = $system_result\n";
    if (defined $Min_Time) {
        @after = POSIX::times();
    }
    if (defined $Stdin) {
        open STDIN, "<&SAVE_STDIN";
        unlink $Stdin if $Stdin_Is_Temporary;
    }

    #
    # Emulate csh "time" command
    #
    if (defined $Min_Time) {
        my $elapsed_ticks    =  $after[0] - $before[0];
        my $user_CPU_ticks   = ($after[1] - $before[1]) +   # this process
                               ($after[3] - $before[3]);    # child processes
        my $system_CPU_ticks = ($after[2] - $before[2]) +   # this process
                               ($after[4] - $before[4]);    # child processes

        my $percent_usage;
        if ($elapsed_ticks == 0) {
            $percent_usage = 0.0;
        }
        else {
            $percent_usage = ($user_CPU_ticks + $system_CPU_ticks)
                             / $elapsed_ticks * 100;
        }

        my $elapsed_seconds    = $elapsed_ticks    / $CLK_TCK;
        my $user_CPU_seconds   = $user_CPU_ticks   / $CLK_TCK;
        my $system_CPU_seconds = $system_CPU_ticks / $CLK_TCK;

        if ($elapsed_seconds >= $Min_Time) {
            printf "%.2fu %.2fs %s %.1f%%\n",
                   $user_CPU_seconds,
                   $system_CPU_seconds,
                   Elapsed_Time_Image $elapsed_seconds,
                   $percent_usage;
        }
    }
    if ($Background) {
        exit;
    }
    elsif (defined $User and not $Config{USE_SDSC_SU}) {
        #
        # This is the child process; bail out and let the parent handle
        # the consequences.  Try to arrange for $? after the parent's
        # call to waitpid to match what it would have been if the parent
        # had called system.
        #
        my $Result = Get_Result $system_result, 0;
        if (defined $Result->{signal}) {
            Debug "Child: kill $Result->{signal}, $$\n";
            kill $Result->{signal}, $$;
        }
        else {
            Debug "Child: exit $Result->{status}\n";
            exit $Result->{status};
        }
    }

    return Get_Result $system_result, $Check;
} # Execute

# ----------------------------------------------------------------------

#
# Confirm that the necessary services are specified in
# /etc/services (or the NIS equivalent).
#
sub Check_Services() {
    my %expected_name = ( 2119 => 'gsigatekeeper',
                          2135 => 'gris',
                          2811 => 'gsiftp' );
    my @errors = ();
    foreach my $port (sort keys %expected_name) {
        my @serv = getservbyport $port, 'tcp';
        if (not @serv) {
            push @errors,
                 "    No service on port $port, " .
                 "expected $expected_name{$port}\n";
        }
        elsif ($serv[0] ne $expected_name{$port}) {
            push @errors,
                 "    Service on port $port is \"$serv[0]\", ",
                  "should be \"$expected_name{$port}\"\n";
        }
    }
    if (@errors) {
        push @manual_steps,
             "Correct /etc/services or equivalent:\n" .
             join('', @errors);
    }
} # Check_Services

# ----------------------------------------------------------------------

sub Cleanup() {
    if (defined $working_dir) {
        if ($Cleanup) {
            print ">>> Cleaning up\n";
            #
            # chdir to tmp to make sure we aren't in a directory that
            # we're about to nuke.
            #
            chdir '/tmp';
            Execute @As_Myself, 'rm', '-rf', $working_dir;
        }
        else {
            print ">>> The working directory $working_dir\n",
                  "    has not been cleaned up.\n";
        }
    }
    #
    # Kill any subprocesses still running.
    #
    my @pids = sort { $a <=> $b } keys %Running;
    if (@pids) {
        print "% kill -INT @pids\n";
        kill 'INT', @pids;
    }

    #
    # Print the manual steps to be performed.
    # Don't do this if there was an error processing the config file,
    # or if the '-validate-only' flag was specified.
    #
    if (@manual_steps and $Config_File_Processed and not $Validate_Only) {
        print Manual_Steps_Text @manual_steps;
    }
} # Cleanup

# ----------------------------------------------------------------------

#
# Calls to die() cause this function to be called before exiting.
# Clean up temporary directory.
#
sub Die_Handler($) {
    #
    # Highlight this reminder and put it at the beginning of
    # the @manual_steps array.
    #
    unshift @manual_steps,
            "========================================================\n" .
            "$Program_Name terminated abnormally\n" .
            "Figure out what went wrong before performing these steps\n" .
            "========================================================\n";
    Cleanup();
    #
    # Perl will now print the message and terminate.
    #
}

# ----------------------------------------------------------------------

sub Signal_Handler($) {
    my $signal = $_[0];
    #
    # Highlight this reminder and put it at the beginning of
    # the @manual_steps array.
    #
    unshift @manual_steps,
            "========================================================\n" .
            "$Program_Name terminated by SIG$signal\n" .
            "Figure out what went wrong before performing these steps\n" .
            "========================================================\n";
    Cleanup();
    #
    # For a signal handler, Perl returns to the previous execution.
    # If we want to bail out, we need to do so explicitly.
    #
    exit 1;
}

# ----------------------------------------------------------------------

#
# Given a time, return an ASCII UTC timestamp suitable for use
# in a file name, such as "2002-08-16-183304".
#
sub Timestamp_Of($) {
    my($time) = @_;
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
        gmtime($time);
    return sprintf "%04d-%02d-%02d-%02d%02d%02d",
                   $year + 1900, $mon + 1, $mday, $hour, $min, $sec;
} # Timestamp_Of

# ----------------------------------------------------------------------

#
# Rename the specified file by appending its last modification time to
# its name, returning the name of the backup (which may be ignored if
# it's not needed).  If file doesn't exist, return undef.  May be used
# on directories as well as ordinary files.
#
# Note that we append a '~' character to the name of the backup file;
# this prevents xinetd from processing backup files in the /etc/inetd.d
# directory (and seems like a generally sensible convention).
#
sub Backup($) {
    my($filename) = @_;
    my @stat;

    return undef if not -e $filename;
    @stat = stat $filename or die "${filename}: $!\n";
    my $timestamp = Timestamp_Of $stat[9]; # mtime
    my $backup_name = "$filename-$timestamp~";
    rename $filename, $backup_name or die "$backup_name: $!\n";
    return $backup_name;
} # Backup

# ----------------------------------------------------------------------

#
# Returns true iff the argument is an empty directory.
#
sub Is_Empty_Dir($) {
    my($dir) = @_;
    if (-d $dir) {
        opendir DIR, $dir or die "${dir}: $!\n";
        my @files = grep { $_ ne '.' and $_ ne '..' } readdir DIR;
        closedir DIR;
        if (@files) { return 0; } else { return 1; }
    }
    else {
        return 0;
    }
} # Is_Empty_Dir

# ----------------------------------------------------------------------

#
# Create a backup copy of the named file and edit it so it doesn't
# prompt for user input.  The required edits are determined by the name
# of the file.  This is *extremely* ad-hoc (but not quite as bad as
# guessing what input is expected).
#
sub Fix_Setup_Script($) {
    my($file) = @_;
    if (-e $file) {
        print "% Editing $file\n";
    }
    else {
        print ">>> Fix_Setup_Script: No file $file\n";
        return;
    }
    my $basename = File::Basename::basename $file;
    my $backup_file = Backup $file;

    open ORIG, $backup_file or die "$backup_file: $!\n";
    open NEW, ">$file" or die "${file}: $!\n";
    if ($basename eq 'grid-security-config.in') {
        while (<ORIG>) {
            s/\bread ans\b/ans="" # $&/;
            s/\bread selection\b/echo "q" ; selection="q" ; # $&/;
            print NEW;
        }
    }
    elsif ($basename eq 'setup-ssl-utils.pl') {
        while (<ORIG>) {
            s/^Press return to contine.*//;
            s/\$foo=<STDIN>;/# $&/;
            print NEW;
        }
    }
    elsif ($basename eq 'setup-kca.pl') {
        while (<ORIG>) {
            s/\$myincrement = <STDIN>;/print "0\\n"; \$myincrement = 0; # $&/;
            s/\$myserial = <STDIN>;/print "\\n"; \$myserial = ""; # $&/;
            s/\$resp = <STDIN>;/print "No\\n"; \$resp="No"; # $&/;
            print NEW;
        }
    }
    elsif ($basename eq 'setup-openssh.pl') {
        while (<ORIG>) {
            s/\$response = query_boolean/\$response = "y"; # $&/;
            s/print "Press <return>/# $&/;
            s/\$trash = <STDIN>/# $&/;
            print NEW;
        }
    }
    else {
        #
        # The lack of a newline in the following die() is intentional;
        # it causes Perl to print more information about the error.
        #
        die "Fix_Setup_Script: Unexpected file name \"$file\"";
    }
    close ORIG;
    close NEW;

    my @stat = stat $backup_file;
    my ($mode, $uid, $gid) = ($stat[2], $stat[4], $stat[5]);
    chmod $mode, $file;
    if ($Running_As_Root) {
        chown $uid, $gid, $file;
    }
} # Fix_Setup_Script

# ----------------------------------------------------------------------

sub Inet_Config_Text($$) {
    my($daemon, $service) = @_;

    my $env_arg = "LD_LIBRARY_PATH=$Config{GLOBUS_LOCATION}/lib";
    if (defined $Config{GLOBUS_HOSTNAME}) {
        $env_arg .= " GLOBUS_HOSTNAME=$Config{GLOBUS_HOSTNAME}";
    }

    if ("$daemon/$service" eq 'xinetd/gsigatekeeper') {
        return <<"EOF";
service gsigatekeeper
{
    socket_type     = stream
    protocol        = tcp
    wait            = no
    user            = root
    env             = $env_arg
    server          = $Config{GLOBUS_LOCATION}/sbin/globus-gatekeeper
    server_args     = -conf $Config{GLOBUS_LOCATION}/etc/globus-gatekeeper.conf
    disable         = no
}
EOF
    }
    elsif ("$daemon/$service" eq 'xinetd/gsiftp') {
        return <<"EOF";
service gsiftp
{
    instances       = 1000
    socket_type     = stream
    wait            = no
    user            = root
    env             = $env_arg
    server          = $Config{GLOBUS_LOCATION}/sbin/in.ftpd
    server_args     = -l -a -G $Config{GLOBUS_LOCATION}
    log_on_success  += DURATION USERID
    log_on_failure  += USERID
    nice            = 10
    disable         = no
}
EOF
    }
    elsif ("$daemon/$service" eq 'inetd/gsigatekeeper') {
        return "gsigatekeeper   stream tcp nowait root " .
               "/usr/bin/env env $env_arg " .
               "$Config{GLOBUS_LOCATION}/sbin/globus-gatekeeper " .
               "-conf $Config{GLOBUS_LOCATION}/etc/globus-gatekeeper.conf\n";
    }
    elsif ("$daemon/$service" eq 'inetd/gsiftp') {
        return "gsiftp          stream tcp nowait root " .
               "/usr/bin/env env $env_arg " .
               "$Config{GLOBUS_LOCATION}/sbin/in.ftpd " .
               "-l -a -G $Config{GLOBUS_LOCATION}\n";
    }
    else {
        die "Internal error, bad arguments to Inet_Config_Text()\n" .
            "    daemon=\"$daemon\", service=\"$service\"";
    }
} # Inet_Config_Text

# ----------------------------------------------------------------------

sub Manual_Steps_Text(@) {
    my @manual_steps = @_;
    my $result = join "\n", ">>> To be done manually:\n", @manual_steps;
    my $stars = '*' x 72;
    $result =~ s/^/* /gm;
    $result = "$stars\n" .
              $result .
              "$stars\n" .
              Time_Image(time) . "\n";
    return $result;
} # Manual_Steps_Text

# ----------------------------------------------------------------------

#
# If a configuration variable has been specified for the command, return
# its value; otherwise search for it in $PATH.
#
sub Find_Command($$) {
    my ($name, $config) = @_;
    if (defined $config) {
        return $config;
    }
    else {
        foreach my $dir (split /:/, $ENV{PATH}) {
            if (-x "$dir/$name") {
                return "$dir/$name";
            }
        }
    }
    return undef;
} # Find_Command

# ----------------------------------------------------------------------

sub Image($) {
    my($arg) = @_;
    if (defined $arg) {
        $arg =~ s/\n/\\n/g;
        return "\"$arg\"";
    }
    else {
        return 'undef';
    }
} # Image

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Debugging;
} # Debug

# ----------------------------------------------------------------------

sub Release_String() {
    if ($Revision eq $Release_Revision) {
        return "release $Release_Number";
    }
    else {
        return "release $Release_Number+";
    }
} # Release_String

# ----------------------------------------------------------------------

sub Show_Version() {
    print "$Program_Name ", Release_String(), " (revision $Revision)\n";
    exit 1;
} # Show_Version

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Program_Name [options] config_file
$Program_Name uses Perl's Getopt::Long module to parse options.
Options may be prefixed with either "-" or "--".
Option names may be abbreviated uniquely.
    -help               Display this message and exit.
    -version            Display version information and exit.
    -validate-only      Validate the configuration file and exit.
    -cleanup            Delete temporary directory on completion (default).
    -postinstall        Run gpt-postinstall (default).
    -startup            Update system files and start services
                        (default is -nostartup)
    -gpt-verbose        Pass -verbose option to gpt-install and/or gpt-build.
    -gpt-install-only   Pass -install-only option to gpt-build.
                        Doesn't affect binary installations (gpt-install).
    -gpt-ignore-errors  Ignore errors from gpt-install and gpt-build.
    -aix-kludge         Use an existing GPT installation.
    -debugging          Enable debugging.
Most options can be negated by prepending "no".
For example, "-nocleanup" inhibits cleanup.
EOF
    exit 1;
#
# Disabled option:
#   -gpt-log            Pass -log=... option to gpt-build.
#                       Implies -nocleanup, since logs are written to the
#                       temporary directory.
#                       Doesn't affect binary installations (gpt-install).
#
} # Usage
