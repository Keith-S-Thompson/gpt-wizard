#!/usr/bin/perl -w

# $Id: gpt-wizard,v 1.28 2002-08-13 14:47:39-07 kst Exp $
# $Source: /home/kst/CVS_smov/tools/gpt-wizard/gpt-wizard,v $

#
# To do:
#
#     Start other services (configurable).
#
#     We warn about putting parts of Globus on local file
#     systems; consider automating this.
#
#     Automatically set up to report to one or more GIIS servers.
#

use strict;

use File::Basename ();
use Getopt::Long ();
use POSIX ();

sub Get_Config($);
sub Check_Config_Vars();
sub Substitute($);
sub Elapsed_Time_Image($);
sub Time_Image($);
sub Make_Temp_File($);
sub Get_Result($$);
sub Execute(@);
sub Check_Services();
sub Die_Handler($);
sub Debug(@);
sub Usage(@);

#
# Make warnings fatal.
#
$SIG{__WARN__} = sub { die @_ };

my $Prog_Name = File::Basename::basename $0;
my $Revision = '$Revision: 1.28 $';
if ($Revision =~ /^\$Revision: 1.28 $$/) {
    $Revision = $1;
}
my $Help = undef;
my $Debugging = undef;
my $Cleanup = 1;
my @Opts = ( 'help'      => \$Help,
             'debugging' => \$Debugging,
             'cleanup!'  => \$Cleanup );
Getopt::Long::GetOptions @Opts or Usage;
Usage if $Help;

$SIG{__DIE__} = \&Die_Handler;

my $temp_file_serial_number = 0;
my @manual_steps = ();

Usage if scalar @ARGV != 1;
my $Config_File = $ARGV[0];
my %Config = Get_Config $ARGV[0];
Check_Config_Vars();

my @As_Root      = qw(-time -verbose -check);
my @As_Installer = (qw(-time -verbose -check),
                   "-user=$Config{INSTALLER_USER}.$Config{INSTALLER_GROUP}");

my $CLK_TCK;
eval { $CLK_TCK = &POSIX::CLK_TCK };
if ($@) {
    $CLK_TCK = 100;
    # warn ">>> CLK_TCK not available, assuming 100\n";
}

if ($< != 0) {
    die ">>> $Prog_Name must be run as root\n";
}

$| = 1;

print Time_Image time, "\n";
print "$Prog_Name revision $Revision processing ",
      "$Config_File $Config{CONFIG_FILE_REVISION}\n";

my @installer_pw = getpwnam $Config{INSTALLER_USER};
die ">>> No user $Config{INSTALLER_USER}\n" unless $#installer_pw >= 2;
my @installer_gr = getgrnam $Config{INSTALLER_GROUP};
die ">>> No group $Config{INSTALLER_GROUP}\n" unless $#installer_gr >= 2;
my $installer_uid = $installer_pw[2];
my $installer_gid = $installer_gr[2];
die ">>> installer_uid = $installer_uid\n" unless $installer_uid > 0;
# die ">>> installer_gid = $installer_gid\n" unless $installer_gid > 0;

$ENV{PATH} = $Config{PATH};
umask oct $Config{UMASK} or die "umask $Config{UMASK}: $!\n";

my $tmp_dir = "$Config{TEMP_DIR}/install-nmi-" . time . "-$$";
mkdir $tmp_dir or die "$tmp_dir: $!\n";
chown $installer_uid, $installer_gid, $tmp_dir
    or die "$tmp_dir: $!\n";
chmod 0700, $tmp_dir or warn "$tmp_dir: $!\n";
chdir $tmp_dir or die "$tmp_dir: $!\n";

#
# Install GPT
#
Execute @As_Installer, 'tar', 'zxf', $Config{GPT_TARBALL};
chdir $Config{GPT_SRC_DIR} or die "$Config{GPT_SRC_DIR}: $!\n";
$ENV{GPT_LOCATION} = $Config{GPT_LOCATION};
mkdir $ENV{GPT_LOCATION} or die "$ENV{GPT_LOCATION}: $!\n";
chown $installer_uid, $installer_gid, $ENV{GPT_LOCATION}
    or die "$ENV{GPT_LOCATION}: $!\n";
Execute @As_Installer, './build_gpt';

#
# <http://www.nsf-middleware.org/documentation/GPT/index.htm>
# says to delete these two files.  They seem to be installed
# if you use the RPM, but not if you use the source tarball.
#
my @files_to_delete = ();
foreach my $file ('/etc/profile.d/gpt.sh', '/etc/profile.d/gpt.csh') {
    push @files_to_delete, $file if -e $file;
}
if (@files_to_delete) {
    print "% unlink @files_to_delete\n";
    unlink @files_to_delete or warn ">>> $!\n";
}

#
# Confirm GPT installation
#
Execute @As_Installer, "$ENV{GPT_LOCATION}/sbin/gpt-install", '-version';

$ENV{GLOBUS_LOCATION} = $Config{GLOBUS_LOCATION};
mkdir $ENV{GLOBUS_LOCATION} or die "$ENV{GLOBUS_LOCATION}: $!\n";
chown $installer_uid, $installer_gid, $ENV{GLOBUS_LOCATION}
    or die "$ENV{GLOBUS_LOCATION}: $!\n";

foreach my $bundle ( @{$Config{BUNDLE}} ) {
    Execute @As_Installer, "$ENV{GPT_LOCATION}/sbin/gpt-install", $bundle;
}

Execute @As_Installer, "-input=0\n0\nn\n\n",
        "$ENV{GPT_LOCATION}/sbin/gpt-postinstall";

Execute @As_Root, "-input=y\nq\n",
        "$ENV{GLOBUS_LOCATION}/setup/globus/setup-gsi";

Execute @As_Root,
        'cp', $Config{GRID_MAPFILE}, '/etc/grid-security/grid-mapfile';
Execute @As_Root,
        'cp', $Config{HOST_CERT},    '/etc/grid-security/hostcert.pem';
Execute @As_Root,
        'cp', $Config{HOST_KEY},     '/etc/grid-security/hostkey.pem';

chmod 0444, '/etc/grid-security/grid-mapfile';
chmod 0444, '/etc/grid-security/hostcert.pem';
chmod 0400, '/etc/grid-security/hostkey.pem';

chdir '/etc/grid-security' or die "/etc/grid-security: $!\n";
rename 'certificates', 'certificates.orig';
Execute @As_Root,
        'tar', 'zxf', $Config{CA_CERT_TARBALL};

Execute @As_Installer,
        'cp', $Config{LDAP_CERT}, "$ENV{GLOBUS_LOCATION}/etc/server.cert";
Execute @As_Installer,
        'cp', $Config{LDAP_KEY}, "$ENV{GLOBUS_LOCATION}/etc/server.key";
chmod 0400, "$ENV{GLOBUS_LOCATION}/etc/server.key";

opendir DIR, $Config{INET_DIR} or die "$Config{INET_DIR}: $!\n";
my @files = grep { $_ ne '.' and $_ ne '..' } sort readdir DIR;
closedir DIR;

if ($Config{INET_DAEMON} eq 'xinetd') {
    foreach my $file (@files) {
        print "Copying $file to /etc/xinetd.d\n";
        open IN, "< $Config{INET_DIR}/$file"
            or die "$Config{INET_DIR}/${file}: $!\n";
        open OUT, "> /etc/xinetd.d/$file"
            or die "/etc/xinetd.d/${file}: $!\n";
        while (<IN>) {
            s/\@(\w+)\@/Substitute $1/eg;
            print OUT;
        }
        close IN;
        close OUT;
    }
    Execute @As_Root, qw(/etc/init.d/xinetd reload);
}
else {
    push @manual_steps,
         "Update /etc/inetd.conf:\n";
    foreach my $file (@files) {
        push @manual_steps,
             "  ${file}:\n";
        open IN, "< $Config{INET_DIR}/$file"
            or die "$Config{INET_DIR}/${file}: $!\n";
        while (<IN>) {
            chomp;
            s/\@(\w+)\@/Substitute $1/eg;
            push @manual_steps,
                 "    $_\n";
        }
        close IN;
    }
    if (-x '/etc/init.d/inet') {
        push @manual_steps,
             "Execute as root \"/etc/init.d/inet reload\"\n";
    }
    else {
        push @manual_steps,
             "Reload or restart inetd\n";
    }
}

if ($Config{BATCH_SYSTEM} ne 'none') {
    Execute @As_Installer,
            "$ENV{GLOBUS_LOCATION}/setup/globus/setup-globus-gram-job-manager",
            $Config{BATCH_SYSTEM};
    my $libexec = "$ENV{GLOBUS_LOCATION}/libexec";
    push @manual_steps,
         "Fix $ENV{GLOBUS_LOCATION}/libexec/" .
         "globus-script-$Config{BATCH_SYSTEM}-* if necessary\n";
}

push @manual_steps,
     "Make sure that certain parts of the Globus installation, particularly\n" .
     "   the var directory, are on a local file system\n";

Execute @As_Installer,
        "$ENV{GLOBUS_LOCATION}/sbin/SXXgris", 'start';
push @manual_steps,
     "Arrange for \"$ENV{GLOBUS_LOCATION}/sbin/SXXgris start\"\n" .
     "    to be executed by user \"$Config{INSTALLER_USER}\" on system boot\n";

push @manual_steps,
     "Configure to report to a GIIS server\n";

chdir $ENV{HOME};
if ($Cleanup) {
    Execute @As_Root, 'rm', '-rf', $tmp_dir;
}

print '*' x 72, "\n";
print ">>> To be done manually:\n";
print @manual_steps;
print '*' x 72, "\n";
print Time_Image time, "\n";

########################################################################

#
# Read and parse the config file (name given on the command line) and
# return the results as a hash (to be assigned to the global %Config).
#
sub Get_Config($) {
    my %Result = ();
    my($config_file) = @_;

    print "Getting configuration from $config_file\n";

    my %count = ( CONFIG_FILE_REVISION => 0,

                  OS                   => 0,

                  TEMP_DIR             => 0,
                  PATH                 => 0,
                  INSTALLER_USER       => 0,
                  INSTALLER_GROUP      => 0,
                  UMASK                => 0,

                  GPT_TARBALL          => 0,
                  GPT_SRC_DIR          => 0,
                  BUNDLE               => 0,

                  GPT_LOCATION         => 0,
                  GLOBUS_LOCATION      => 0,

                  GRID_MAPFILE         => 0,
                  HOST_CERT            => 0,
                  HOST_KEY             => 0,
                  LDAP_CERT            => 0,
                  LDAP_KEY             => 0,

                  BATCH_SYSTEM         => 0,

                  CA_CERT_TARBALL      => 0,

                  INET_DAEMON          => 0,
                  INET_DIR             => 0 );

    open CONFIG, $config_file or die "$config_file: $!\n";
    while (<CONFIG>) {
        s/#.*$//;
        s/^\s+//;
        s/\s+$//;
        next if /^$/;
        if (/^(\w+)\s*(.*)$/) {
            my ($name, $value) = ($1, $2);
            if (defined $count{$name}) {
                if ($count{$name} == 0) {
                    #
                    # First time we've seen this variable; just set it.
                    #
                    $Result{$name} = $value;
                }
                else {
                    #
                    # We've seen this variable before; append value to
                    # referenced array.
                    #
                    if ($count{$name} == 1) {
                        #
                        # Convert from simple scalar to array reference.
                        #
                        $Result{$name} = [ $Result{$name} ];
                    }
                    push @{$Result{$name}}, $value;
                }
                $count{$name} ++;
            }
            else {
                die "Unrecognized option in $config_file at line $.\n";
            }
        }
        else {
            die "Syntax error in $config_file at line $.\n";
        }
    }
    close CONFIG;

    my @missing = ();
    my @extra = ();
    foreach my $option (sort keys %count) {
        if ($count{$option} == 0) {
            push @missing, $option;
        }
        elsif ($count{$option} > 1) {
            push @extra, $option if $option ne 'BUNDLE';
        }
    }

    if (@missing or @extra) {
        my @errors = ( ">>> Bad config file $config_file\n" );
        foreach (@missing) {
            push @errors, "    Missing option $_\n";
        }
        foreach (@extra) {
            push @errors, "    Multiply specified option $_\n";
        }
        die @errors;
    }

    #
    # Don't let RCS modify the search pattern.
    #
    my $revision_tag = '$' . 'Revision:';
    if ($Result{CONFIG_FILE_REVISION} =~ /^$revision_tag: ([\d.]+) \$$/) {
        $Result{CONFIG_FILE_REVISION} = $1;
    }

    #
    # OS, BATCH_SYSTEM, and INET_DAEMON are case-insensitive; map to
    # lower case.
    #
    $Result{OS}           = lc $Result{OS};
    $Result{BATCH_SYSTEM} = lc $Result{BATCH_SYSTEM};
    $Result{INET_DAEMON}  = lc $Result{INET_DAEMON};

    foreach my $key (sort keys %Result) {
        my $value = $Result{$key};
        if (ref $value eq 'ARRAY') {
            printf "    %-20s => {\n", $key;
            foreach my $elem (@$value) {
                print "        $elem\n";
            }
            print "    }\n";
        }
        else {
            printf "    %-20s => \"%s\"\n", $key, $Result{$key};
        }
    }
    return %Result;
} # Get_Config

# ----------------------------------------------------------------------

sub Substitute($) {
    my($key) = @_;
    if (defined $Config{$key}) {
        return $Config{$key};
    }
    else {
        die "Unrecognized substitution key: $key\n";
    }
} # Substitute

# ----------------------------------------------------------------------

sub Elapsed_Time_Image($) {
    my($seconds) = @_;

    my $h = int($seconds / 3600);
    $seconds -= 3600 * $h;      # Can't use "%"; it truncates.

    my $m = int($seconds / 60);
    $seconds -= 60 * $m;

    if ($h > 0) {
        return sprintf '%d:%02d:%05.2f', $h, $m, $seconds;
    }
    else {
        return sprintf '%d:%05.2f', $m, $seconds;
    }
} # Elapsed_Time_Image

# ----------------------------------------------------------------------

sub Time_Image($) {
    my($time) = @_;
    my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst)
        = gmtime time;
    return sprintf "%s %04d-%02d-%02d %02d:%02d:%02d UTC",
                   (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
                   1900+$year, 1+$mon, $mday, $hour, $min, $sec;
} # Time_Image

# ----------------------------------------------------------------------

sub Make_Temp_File($) {
    my($content) = @_;
    my $filename = sprintf "$Config{TEMP_DIR}/input-%02d",
                           $temp_file_serial_number ++;
    open TMP, ">$filename" or die "${filename}: $!\n";
    print TMP $content;
    close TMP;
    return $filename;
} # Make_Temp_File

# ----------------------------------------------------------------------

sub Get_Result($$) {
    my ($status, $check) = @_;
    my $Result = {};
    my $hi_8 = ($status & 0xff00) >> 8;
    my $lo_8 =  $status & 0x00ff;

    my $WSTOPFLG = 0x007f;
    my $WCOREFLG = 0x0080;

    if ($lo_8 == $WSTOPFLG) {
        $Result->{signal} = $hi_8;
        $Result->{stopped} = 1;
        $Result->{desc} = "stopped, signal $hi_8";
        die $Result->{desc} if $check;
    }
    elsif ($lo_8 == 0) {
        $Result->{status} = $hi_8;
        $Result->{desc} = "exit $hi_8";
        die $Result->{desc} if $check and $Result->{status} != 0;
    }
    elsif ($hi_8 == 0) {
        my $signal = $lo_8;
        if ($signal & $WCOREFLG) {
            $signal &= ~$WCOREFLG;
            $Result->{core} = 1;
        }
        $Result->{signal} = $signal;
        $Result->{desc} = "signal $signal";
        if ($Result->{core}) {
            $Result->{desc} .= " (core dumped)";
        }
        die $Result->{desc} if $check;
    }
    return $Result;
} # Get_Result

# ----------------------------------------------------------------------

sub Execute(@) {
    my @args = @_;
    my $Verbose = 0;
    my $Time = 0;
    my $Background = 0;
    my $Check = 0;
    my $User = undef;
    my $Group = undef;
    my $Stdin = undef;
    my $Stdin_Is_Temporary = undef;
    my @before;
    my @after;
    my $system_result;

    Debug "Execute, scalar \@args = ", scalar @args, "\n";
    my @caller = caller;
    Debug "   Called from $caller[0]::$caller[1] line $caller[2]\n";
    #
    # Process arguments
    #
    while ( scalar @args > 0 && $args[0] =~ /^-/) {
        my $arg = shift @args;
        if ($arg eq '-verbose') {
            $Verbose = 1;
        }
        elsif ($arg eq '-time') {
            $Time = 1;
        }
        elsif ($arg eq '-background') {
            $Background = 1;
        }
        elsif ($arg eq '-check') {
            $Check = 1;
        }
        elsif ($arg =~ /^-user=(.+)$/) {
            $User = $1;
            if ($User =~ /^(.*)[.:](.*)$/) {
                $User = $1;
                $Group = $2;
            }
        }
        elsif ($arg =~ /^-stdin=(.+)$/) {
            $Stdin = $1;
        }
        elsif ($arg =~ /^-input=(.+)$/s) {
            #
            # Need to use "/s" modifier so "." matches "\n"
            #
            $Stdin = Make_Temp_File $1;
            $Stdin_Is_Temporary = 1;
        }
        else {
            die "Execute: Unrecognized argument: $arg\n";
        }
    }

    Debug "   args = @args\n";
    if (defined $User) {
        my @pw = getpwnam $User;
        die "${User}: No such user\n" if not @pw;
        my @gr;
        if (defined $Group) {
            @gr = getgrnam $Group;
            die "${Group}: No such group\n" if not @gr;
        }
        my $uid = $pw[2];
        my $gid = defined $Group ? $gr[2] : undef;
        my $pid;
        if (($pid = fork) == 0) {
            #
            # This is the child process.
            # Set the real and effective user (and group) id,
            # and continue to handle the call.
            #
            $< = $uid;
            $> = $uid;
            if (defined $gid) {
                $( = $gid;
                $) = $gid;
            }
        }
        else {
            #
            # This is the parent process.
            # Wait for the child to finish.  
            #
            waitpid $pid, 0;
            return Get_Result $?, $Check;
        }
    }

    if ($Verbose) {
        Debug "Building command_string, args = @args\n";
        my $command_string = '% ';
        $command_string .= "[$User] " if defined $User;
        $command_string .= 'time ' if $Time;
        $command_string .= "@args";
        $command_string .= " < $Stdin" if defined $Stdin;
        $command_string .= " &" if $Background;
        print "$command_string\n";
    }

    if ($Background) {
        my $pid = fork;
        if ($pid != 0) {
            #
            # I'm the parent
            #
            my $Result = {};
            $Result->{pid} = $pid;
            return $Result;
        }
    }

    if (defined $Stdin) {
        open SAVE_STDIN, "<&STDIN";
        print SAVE_STDIN if 0;          # keep "perl -w" happy
        close STDIN;
        open STDIN, "<$Stdin" or die "${Stdin}: $!\n";
    }
    if ($Time) {
        @before = POSIX::times;
    }
    $system_result = system @args;
    if ($Time) {
        @after = POSIX::times();
    }
    if (defined $Stdin) {
        open STDIN, "<&SAVE_STDIN";
        unlink $Stdin if $Stdin_Is_Temporary;
    }

    #
    # Emulate csh "time" command
    #
    if ($Time) {
        my $elapsed_ticks    =  $after[0] - $before[0];
        my $user_CPU_ticks   = ($after[1] - $before[1]) +   # this process
                               ($after[3] - $before[3]);    # child processes
        my $system_CPU_ticks = ($after[2] - $before[2]) +   # this process
                               ($after[4] - $before[4]);    # child processes

        # print "\$elapsed_ticks    = $elapsed_ticks\n";
        # print "\$user_CPU_ticks   = $user_CPU_ticks\n";
        # print "\$system_CPU_ticks = $system_CPU_ticks\n";
        my $percent_usage;
        if ($elapsed_ticks == 0) {
            $percent_usage = 0.0;
        }
        else {
            $percent_usage = ($user_CPU_ticks + $system_CPU_ticks)
                             / $elapsed_ticks * 100;
        }

        my $elapsed_seconds    = $elapsed_ticks    / $CLK_TCK;
        my $user_CPU_seconds   = $user_CPU_ticks   / $CLK_TCK;
        my $system_CPU_seconds = $system_CPU_ticks / $CLK_TCK;

        printf "%.2fu %.2fs %s %.1f%%\n",
               $user_CPU_seconds,
               $system_CPU_seconds,
               Elapsed_Time_Image $elapsed_seconds,
               $percent_usage;
    }
    if ($Background or defined $User) {
        #
        # This is the child process; bail out and let the parent handle
        # the consequences.
        #
        exit(($system_result & 0xff00) >> 8);
    }

    return Get_Result $system_result, $Check;
} # Execute

# ----------------------------------------------------------------------

sub Check_Config_Vars() {
    my @errors = ();

    my @inet_daemons  = qw( xinetd inetd );
    my @batch_systems = qw( condor easymcs fork glunix grd loadleveler
                            lsf nqe nswc pbs pexec prun );
    my %is_inet_daemon  = map { ( $_ => 1 ) } @inet_daemons;
    my %is_batch_system = map { ( $_ => 1 ) } @batch_systems;

    if ($Config{OS} ne 'linux') {
        push @errors, "Unsupported OS \"$Config{OS}\"\n";
    }

    if (not $is_inet_daemon{$Config{INET_DAEMON}}) {
        push @errors, "INET_DAEMON must be one of: @inet_daemons\n";
    }
    if ($Config{BATCH_SYSTEM} ne 'none' and
        not $is_batch_system{$Config{BATCH_SYSTEM}})
    {
        push @errors, "BATCH_SYSTEM must be \"none\" or one of:\n" .
                      "    @batch_systems\n";
    }

    foreach my $key (qw(TEMP_DIR INET_DIR)) {
        if (not (-d $Config{$key} and -w _)) {
            push @errors, "Bad $key directory \"$Config{$key}\n";
        }
    }

    foreach my $key (qw(GPT_TARBALL
                        GRID_MAPFILE
                        HOST_CERT HOST_KEY
                        LDAP_CERT LDAP_KEY
                        CA_CERT_TARBALL))
    {
        if (not (-f $Config{$key} and -r _)) {
            push @errors, "Can't read $key file \"$Config{$key}\"\n";
        }
    }
    foreach my $bundle (@{$Config{BUNDLE}}) {
        if (not (-f $bundle and -r _)) {
            push @errors, "Can't read bundle file $bundle\n";
        }
    }

    foreach my $key (qw(GPT_LOCATION GLOBUS_LOCATION)) {
        if (-e $Config{$key}) {
            push @errors, "$key \"$Config{$key}\" already exists\n";
        }
    }
    
    if (@errors) {
        die ">>> Error(s) in config file ${Config_File}:\n", @errors
    }
} # Check_Config_Vars

# ----------------------------------------------------------------------

sub Check_Services() {
    my %expected_name = ( 2119 => 'gsigatekeeper',
                          2135 => 'gris',
                          2811 => 'gsiftp' );
    foreach my $port (sort keys %expected_name) {
        my @serv = getservbyport $port, $expected_name{$port};
        if (not @serv) {
            print ">>> No service on port $port ",
                  "(expected $expected_name{$port})\n";
        }
        elsif ($serv[0] ne $expected_name{$port}) {
            print ">>> Service on port $port is \"$serv[0]\", ",
                  "should be \"$expected_name{$port}\"\n";
        }
    }
} # Check_Services

# ----------------------------------------------------------------------

sub Die_Handler($) {
    if ($Cleanup and defined $tmp_dir) {
        print ">>> Cleaning up\n";
        Execute @As_Root, 'rm', '-rf', $tmp_dir;
    }
    print Time_Image time, "\n";
} # Die_Handler

# ----------------------------------------------------------------------

sub Debug(@) {
    print @_ if $Debugging;
} # Debug

# ----------------------------------------------------------------------

sub Usage(@) {
    print @_ if @_;
    print <<"EOF";
Usage: $Prog_Name [options] config_file
    -help      : Display this message and exit
    -cleanup   : Delete temporary directory on completion (default)
    -nocleanup : Do not delete temporary directory
    -debugging : Enable debugging

EOF
    exit 1;
} # Usage
